!function(c){var t={};function g(n){if(t[n])return t[n].exports;var I=t[n]={i:n,l:!1,exports:{}};return c[n].call(I.exports,I,I.exports,g),I.l=!0,I.exports}g.m=c,g.c=t,g.d=function(c,t,n){g.o(c,t)||Object.defineProperty(c,t,{enumerable:!0,get:n})},g.r=function(c){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(c,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(c,"__esModule",{value:!0})},g.t=function(c,t){if(1&t&&(c=g(c)),8&t)return c;if(4&t&&"object"==typeof c&&c&&c.__esModule)return c;var n=Object.create(null);if(g.r(n),Object.defineProperty(n,"default",{enumerable:!0,value:c}),2&t&&"string"!=typeof c)for(var I in c)g.d(n,I,function(t){return c[t]}.bind(null,I));return n},g.n=function(c){var t=c&&c.__esModule?function(){return c.default}:function(){return c};return g.d(t,"a",t),t},g.o=function(c,t){return Object.prototype.hasOwnProperty.call(c,t)},g.p="",g(g.s=0)}([function(module,__webpack_exports__,__webpack_require__){"use strict";eval("__webpack_require__.r(__webpack_exports__);\n\n// CONCATENATED MODULE: ./src/js/weatherInformation.js\nclass WeatherInformation {\r\n    constructor(weatherInfo) {\r\n      this.location = weatherInfo.name,\r\n      this.country = weatherInfo.sys.country\r\n      this.date = new Date(),\r\n      this.temp = weatherInfo.main.temp,\r\n      this.iconName = weatherInfo.weather[0].main,\r\n      this.pressure = weatherInfo.main.pressure,\r\n      this.humidity = weatherInfo.main.humidity,\r\n      this.windSpped = weatherInfo.wind.speed\r\n    }\r\n  \r\n    setLocation() {\r\n      const locationID = document.getElementsByClassName(\"headText__location--js\")[0];\r\n      locationID.innerHTML = `in ${this.location}, ${this.country}`;\r\n    }\r\n    setDate() {\r\n      const dateID = document.getElementsByClassName(\"headText__date--js\")[0];\r\n      dateID.innerHTML = `Today ${this.date.getDate()}th, ${this.date.toLocaleString('en-EN', {month: 'long'})}`\r\n    }\r\n    \r\n    setTemp() {\r\n      const tempID = document.getElementsByClassName(\"headText--degrees-js\")[0];\r\n      tempID.innerHTML = `${this.temp.toFixed(1)} °C`;\r\n    }\r\n  \r\n    setPressure() {\r\n      const pressureID = document.getElementsByClassName(\"weatherToday__pressure--js\")[0];\r\n      pressureID.innerHTML = `${this.pressure} hPa`;\r\n    }\r\n  \r\n    setHumidity() {\r\n      const humidityID = document.getElementsByClassName(\"weatherToday__humidity--js\")[0];\r\n      humidityID.innerHTML = `${this.humidity} %`;\r\n    }\r\n  \r\n    setWindSpeed() {\r\n      const windSpeedID = document.getElementsByClassName(\"weatherToday__windSpeed--js\")[0];\r\n      windSpeedID.innerHTML = `${this.windSpped} m/s`;\r\n    }\r\n  \r\n    setWeatherInformation() {\r\n      this.setLocation();\r\n      this.setDate();\r\n      this.setTemp();\r\n      this.setPressure();\r\n      this.setHumidity();\r\n      this.setWindSpeed();\r\n    }\r\n  \r\n    weatherIcon(weather) {\r\n      let currentDate = new Date();\r\n      currentDate = currentDate.getHours();\r\n      switch(weather) {\r\n        case 'thunderstorm':\r\n          return 'storm.svg';\r\n          break;\r\n        case 'Drizzle':\r\n          return 'Drizzle.svg';\r\n          break;\r\n        case 'Rain':\r\n          return 'Rain.svg';\r\n          break;\r\n        case 'Snow':\r\n          return 'Snowflake.svg';\r\n          break;\r\n        case 'Atmosphere':\r\n          return 'fog.svg';\r\n          break;\r\n        case 'Clear':\r\n          if(currentDate <= 20) {\r\n            return 'sun.svg';\r\n            break;\r\n          }\r\n          else {\r\n            return 'moon.svg';\r\n            break;\r\n          }\r\n        case 'Clouds':\r\n          return 'Clouds.svg'\r\n          break;\r\n      }\r\n    }\r\n  \r\n    setImage() {\r\n      const imageID = document.getElementsByClassName(\"weatherImage--js\")[0];\r\n      const weatherName = this.weatherIcon(this.iconName);\r\n      imageID.src = `assets/img/${weatherName}`;\r\n    }\r\n    roundTemp(temp) {\r\n      return Math.round((temp * 100)/100);\r\n    }\r\n  }\n// CONCATENATED MODULE: ./src/js/chartClass.js\nclass Chart {\r\n    constructor(weatherData, axisXposition) {\r\n      this.axisXposition = axisXposition;\r\n      this.weatherByHour = weatherData;\r\n      this.condition = false;\r\n      this.state = {};\r\n      this.tooltip = document.getElementsByClassName(\"chartTemp__tooltip\")[0];\r\n      this.canvas = document.getElementById(\"chartTemp__canvas\");\r\n      this.ctx = this.canvas.getContext(\"2d\");\r\n    }\r\n  \r\n    canvasDimensions() {\r\n      this.canvas.width = 660;\r\n      this.canvas.height = 309;\r\n    }\r\n  \r\n    blocks(count) {\r\n      return count * 40;\r\n    }\r\n  \r\n    drawGrid() {\r\n      let gridX = 40;\r\n      let gridY = 40;\r\n      const cellSize = 40;\r\n      this.ctx.beginPath();\r\n      this.ctx.strokeStyle = \"lightgrey\";\r\n    \r\n      while (gridX <= this.canvas.width - 20) {\r\n        this.ctx.moveTo(gridX, 20);\r\n        this.ctx.lineTo(gridX, this.canvas.height - 20);\r\n        gridX += cellSize;\r\n      }\r\n      while (gridY <= this.canvas.height - 20) {\r\n        this.ctx.moveTo(20, gridY);\r\n        this.ctx.lineTo(this.canvas.width - 10, gridY);\r\n        gridY += cellSize;\r\n      }\r\n      this.ctx.stroke();\r\n    }\r\n  \r\n    async drawAxis(hours) {\r\n      this.ctx.beginPath();\r\n      this.ctx.strokeStyle = \"black\";\r\n      this.ctx.moveTo(this.blocks(1), this.blocks(1 / 2));\r\n      this.ctx.lineTo(this.blocks(1), this.blocks(7));\r\n      this.ctx.lineTo(this.blocks(16), this.blocks(7));\r\n    \r\n      this.ctx.moveTo(this.blocks(1), this.blocks(7));\r\n      let text = 0;\r\n      let textY = this.blocks(7);\r\n      for (let i = 1; i <= 7; i++) {\r\n        this.ctx.strokeText(text, this.blocks(1 / 2), textY);\r\n        textY -= 40;\r\n        text += 5;\r\n      }\r\n    \r\n      this.ctx.moveTo(this.blocks(2), this.blocks(7));\r\n      let textX = this.blocks(1.9);\r\n    \r\n      for (let i = 0; i <= 15; i++) {\r\n        this.ctx.strokeText(hours[i], textX, this.blocks(7.5));\r\n        textX += 40;\r\n      }\r\n      this.ctx.stroke();\r\n    }\r\n    timestampToTime(stamp) {\r\n      let date = new Date(stamp * 1000);\r\n      return date.getHours();\r\n    }\r\n    \r\n    mapAndFilter(tempArray) {\r\n      tempArray = tempArray.map((el) => this.timestampToTime(el));\r\n      tempArray = tempArray.filter((el) => el % 2 == 0);\r\n      return tempArray;\r\n    }\r\n    \r\n    temperatureToChartCoords(temp){\r\n      let temperature = temp.map((el) => el / 5);\r\n      temperature = temperature.slice(0,15);\r\n      return temperature;\r\n    }\r\n    \r\n    getHoursCoords() {\r\n      let hourOfTemp = [...Array(17).keys()]\r\n      hourOfTemp = hourOfTemp.slice(2, 17);\r\n    \r\n      return hourOfTemp;\r\n    }\r\n    \r\n    drawChart(temperature) {\r\n      const tempHours = this.getHoursCoords();\r\n      let i = 1;\r\n      const context = this.ctx\r\n      const block = this.blocks.bind(this);\r\n      const axisXposition = this.axisXposition;\r\n      function animation() {\r\n        if (i <= temperature.length) {\r\n          window.requestAnimationFrame(animation);\r\n        }\r\n        context.strokeStyle = \"#FFE74A\";\r\n        context.lineWidth = 3;\r\n        context.beginPath();\r\n        context.moveTo(block(tempHours[i-1]), axisXposition - block(temperature[i-1]));\r\n        context.arc(block(tempHours[i-1]), axisXposition - block(temperature[i-1]), 3, 0, Math.PI * 2, true);\r\n        context.lineTo(block(tempHours[i]), axisXposition - block(temperature[i]));\r\n        context.stroke();\r\n        i++;\r\n      }\r\n      animation();\r\n    }\r\n    \r\n    async waitForGrid(ms) {\r\n      return new Promise(r => setTimeout(r, ms));\r\n    }\r\n    \r\n    getMousePosition(evt) {\r\n      let rect = this.canvas.getBoundingClientRect();\r\n      return {\r\n        x: evt.clientX - rect.left,\r\n        y: evt.clientY - rect.top\r\n      };\r\n    }\r\n    \r\n    filterTemperature(temperature) {\r\n      const temp = temperature\r\n        .map((obj) => obj.temp)\r\n        .filter((el, index) => index % 2 == 0);\r\n    \r\n      return temp;\r\n    }\r\n    \r\n    temperatureToPixel(temp){\r\n      temp = temp.map(el => this.axisXposition - this.blocks(el));\r\n      return temp;\r\n    }\r\n    \r\n    hoursToPixel(hours) {\r\n      const hourrs = hours.map(el => this.blocks(el));\r\n      return hourrs;\r\n    }\r\n    \r\n    createTempObj(hour, temp, hourOfTemp, tempInHour){\r\n      const tempPointCoords = [];\r\n      for (let i = 0; i < temp.length; i++){\r\n        tempPointCoords.push({\r\n          x: hour[i],\r\n          y: temp[i],\r\n          xmin: hour[i] - 3,\r\n          xmax: hour[i] + 3,\r\n          ymin: temp[i] - 3,\r\n          ymax: temp[i] + 3,\r\n          hourTemp: {\r\n            hour: hourOfTemp[i],\r\n            temp: tempInHour[i]\r\n          },\r\n    \r\n        })\r\n      }\r\n      return tempPointCoords;\r\n    }\r\n    \r\n    drawPoint(coords = {}, radius, color = 'white') {\r\n      const mouseCoordinate = coords;\r\n      this.ctx.strokeStyle = color;\r\n      this.ctx.beginPath();\r\n      this.ctx.moveTo(mouseCoordinate.x, mouseCoordinate.y);\r\n      this.ctx.arc(mouseCoordinate.x, mouseCoordinate.y, radius, 0, Math.PI * 2, true);\r\n      this.ctx.fillStyle = color;\r\n      this.ctx.fill();\r\n      this.ctx.stroke();\r\n    }\r\n    \r\n  \r\n    addPopUp(tempPoint) {\r\n      this.canvas.addEventListener('mousemove', (e) => {\r\n        const mouseCoords = this.getMousePosition(e);\r\n        let boools = tempPoint.filter(el => {\r\n          const a = el.xmin <= mouseCoords.x;\r\n          const b = mouseCoords.x <= el.xmax;\r\n          const c = el.ymin <= mouseCoords.y;\r\n          const d = mouseCoords.y <= el.ymax;\r\n          return (a && b && c && d)})\r\n        \r\n        if(boools.length) {\r\n          this.drawPoint(boools[0], 1);\r\n          this.state = {...boools[0]};\r\n          this.condition = true;\r\n          if (this.canvas.width - (this.state.x + 5) <= 80){\r\n            this.tooltip.style.left = `${this.state.x - 85}px`\r\n            this.tooltip.style.top = `${this.state.y - 35}px`;\r\n            \r\n          }\r\n          else {\r\n            this.tooltip.style.left = `${this.state.x + 5}px`;\r\n            this.tooltip.style.top = `${this.state.y - 35}px`;\r\n          }\r\n          this.tooltip.style.display = 'flex';\r\n          this.tooltip.innerHTML = `Time: ${this.state.hourTemp.hour}:00, Temp: ${this.state.hourTemp.temp}°C`;\r\n        } \r\n        else if(!boools.length) {\r\n          this.drawPoint(this.state, 3, \"#FFE74A\");\r\n          this.condition = false;\r\n          this.state = {};\r\n          this.tooltip.style.display = 'none';\r\n        } \r\n      })\r\n    }\r\n    \r\n    async chart() {\r\n      const hourOfWeather = this.mapAndFilter(this.weatherByHour.map((obj) => obj.dt));\r\n      let temperature = this.filterTemperature(this.weatherByHour);\r\n      const temperatureCoords = this.temperatureToChartCoords(temperature);\r\n      \r\n      const tempPixels = this.temperatureToPixel(temperatureCoords, this.axisXposition);\r\n      const hoursPixels = this.hoursToPixel(this.getHoursCoords());\r\n      \r\n      const tempPoints = this.createTempObj(hoursPixels, tempPixels, hourOfWeather, temperature);\r\n    \r\n      this.canvasDimensions();\r\n      this.drawGrid();\r\n      this.drawAxis(hourOfWeather);\r\n      await this.waitForGrid(500);\r\n      this.drawChart(temperatureCoords)\r\n      this.addPopUp(tempPoints);\r\n    }\r\n  \r\n  }\n// CONCATENATED MODULE: ./src/js/weekForecastClass.js\nclass WeekForecast {\r\n  constructor(weekForecastData) {\r\n    this.weekData = weekForecastData;\r\n    this.weatherForecastContainer = document.getElementsByClassName(\"weatherForecast--js\");\r\n    this.weatherForecastContainer = this.weatherForecastContainer[0];\r\n  }\r\n\r\n  sliceWeekDataArray(){\r\n    this.weekData = this.weekData.slice(1,8);\r\n    console.log(this.weekData)\r\n  }\r\n  getTimestampToTime(timestamp) {\r\n    const time = new Date(timestamp * 1000);\r\n    return time.getDay();\r\n  }\r\n  getNameOfWeek(number) {\r\n    switch (number) {\r\n      case 0:\r\n        return \"Sun\";\r\n        break;\r\n      case 1:\r\n        return \"Mon\";\r\n        break;\r\n      case 2:\r\n        return \"Tue\";\r\n        break;\r\n      case 3:\r\n        return \"Wed\";\r\n        break;\r\n      case 4:\r\n        return \"Thur\";\r\n        break;\r\n      case 5: \r\n        return \"Fri\";\r\n        break;\r\n      case 6:\r\n        return \"Sat\";\r\n        break\r\n    }\r\n  }\r\n  getWeatherParameters(){\r\n    this.weekData = this.weekData.map(el => {\r\n      return {\r\n        day: this.getNameOfWeek(this.getTimestampToTime(el.dt)), \r\n        temp: el.temp.day,\r\n        weather: el.weather[0].main\r\n      }\r\n    });\r\n    console.log(this.weekData)\r\n  }\r\n\r\n  putWeatherIntoSection(){\r\n    this.weatherForecastContainer.innerHTML = '';\r\n    this.weekData.forEach(el => {\r\n      this.weatherForecastContainer.innerHTML += `<div class=\"weatherForecast__day weatherForecast__day--js\"><img class=\"weatherForecast__dayElement\" src='/assets/img/weathericons/${this.weatherIcon(el.weather)}' alt=''></img><div class=\"weatherForecast__dayElement\"><p>${el.day}<br>${el.temp}</p></div></div>`\r\n    })\r\n  }\r\n\r\n  addWeatherForecast() {\r\n    this.sliceWeekDataArray();\r\n    this.getWeatherParameters();\r\n    this.putWeatherIntoSection();\r\n  }\r\n\r\n  weatherIcon(weather) {\r\n    let currentDate = new Date();\r\n    currentDate = currentDate.getHours();\r\n    switch(weather) {\r\n      case 'thunderstorm':\r\n        return 'storm.svg';\r\n        break;\r\n      case 'Drizzle':\r\n        return 'Drizzle.svg';\r\n        break;\r\n      case 'Rain':\r\n        return 'Rain.svg';\r\n        break;\r\n      case 'Snow':\r\n        return 'Snowflake.svg';\r\n        break;\r\n      case 'Atmosphere':\r\n        return 'fog.svg';\r\n        break;\r\n      case 'Clear':\r\n        if(currentDate <= 20) {\r\n          return 'sun.svg';\r\n          break;\r\n        }\r\n        else {\r\n          return 'moon.svg';\r\n          break;\r\n        }\r\n      case 'Clouds':\r\n        return 'Clouds.svg'\r\n        break;\r\n    }\r\n  }\r\n\r\n}\n// CONCATENATED MODULE: ./src/js/main.js\n\r\n\r\n\r\n\r\n// service worker registration - remove if you're not going to use it\r\n\r\nif (\"serviceWorker\" in navigator) {\r\n  window.addEventListener(\"load\", function () {\r\n    navigator.serviceWorker.register(\"serviceworker.js\").then(\r\n      function (registration) {\r\n        // Registration was successful\r\n        console.log(\r\n          \"ServiceWorker registration successful with scope: \",\r\n          registration.scope\r\n        );\r\n      },\r\n      function (err) {\r\n        // registration failed :(\r\n        console.log(\"ServiceWorker registration failed: \", err);\r\n      }\r\n    );\r\n  });\r\n}\r\n\r\n// place your code below\r\nconst apiKey = \"53c5e97675c8d3d8da07e56aec5a3a22\";\r\nconst axisXposition = 280; // X axis is on 280px Canvas Height;\r\nlet classStatus = false;\r\n\r\n(function () {\r\n  var lastTime = 0;\r\n  var vendors = ['ms', 'moz', 'webkit', 'o'];\r\n  for (var x = 0; x < vendors.length && !window.requestAnimationFrame; ++x) {\r\n      window.requestAnimationFrame = window[vendors[x] + 'RequestAnimationFrame'];\r\n      window.cancelAnimationFrame = window[vendors[x] + 'CancelAnimationFrame'] || window[vendors[x] + 'CancelRequestAnimationFrame'];\r\n  }\r\n\r\n  if (!window.requestAnimationFrame) window.requestAnimationFrame = function (callback, element) {\r\n      var currTime = new Date().getTime();\r\n      var timeToCall = Math.max(0, 16 - (currTime - lastTime));\r\n      var id = window.setTimeout(function () {\r\n          callback(currTime + timeToCall);\r\n      },\r\n      timeToCall);\r\n      lastTime = currTime + timeToCall;\r\n      return id;\r\n  };\r\n\r\n  if (!window.cancelAnimationFrame) window.cancelAnimationFrame = function (id) {\r\n      clearTimeout(id);\r\n  };\r\n}());\r\n\r\n\r\n\r\nfunction success(loc) {\r\n  const { coords } = loc;\r\n}\r\n\r\nfunction error(err) {\r\n  console.warn(`ERROR(${err.code}): ${err.message}`);\r\n}\r\n\r\nconst options = {\r\n  enableHighAccuracy: true,\r\n  timeout: 5000,\r\n  maximumAge: 0,\r\n};\r\n\r\nfunction consolValue(val) {\r\n  return val;\r\n}\r\n\r\nfunction main_location() {\r\n  return new Promise((resolve, reject) =>\r\n    navigator.geolocation.getCurrentPosition(resolve, error)\r\n  );\r\n}\r\n\r\nasync function getLocation(location) {\r\n  let position = location;\r\n  let weatherByPosition;\r\n  let weatherByHour;\r\n  let nextSevenDays;\r\n  if (typeof position === 'object') {\r\n    \r\n    position = await position.coords;\r\n    const { latitude, longitude } = position;\r\n  \r\n    weatherByPosition = await fetch(\r\n      `https://api.openweathermap.org/data/2.5/weather?lat=${latitude}&lon=${longitude}&appid=${apiKey}&units=metric&lang=pl`\r\n    );\r\n    weatherByPosition = await weatherByPosition.json();\r\n    \r\n    weatherByHour = await fetch(`https://api.openweathermap.org/data/2.5/onecall?lat=${latitude}&lon=${longitude}&\r\n    exclude=hourly&appid=${apiKey}&units=metric`);\r\n    weatherByHour = await weatherByHour.json();\r\n    weatherByHour = weatherByHour.hourly;\r\n    \r\n    nextSevenDays = await fetch(`https://api.openweathermap.org/data/2.5/onecall?lat=${latitude}&lon=${longitude}&\r\n    exclude=daily&appid=${apiKey}&units=metric`)\r\n    nextSevenDays = await nextSevenDays.json();\r\n    nextSevenDays = nextSevenDays.daily;\r\n  }\r\n  else {\r\n    weatherByPosition = await fetch(`https://api.openweathermap.org/data/2.5/weather?q=${position}&appid=${apiKey}&units=metric`)\r\n    weatherByPosition = await weatherByPosition.json();\r\n    \r\n    const coords = weatherByPosition.coord;\r\n    console.log(coords)\r\n    weatherByHour = await fetch(`https://api.openweathermap.org/data/2.5/onecall?lat=${coords.lat}&lon=${coords.lon}&\r\n    exclude=hourly&appid=${apiKey}&units=metric`);\r\n    weatherByHour = await weatherByHour.json();\r\n    \r\n    weatherByHour = weatherByHour.hourly;\r\n\r\n    nextSevenDays = await fetch(`https://api.openweathermap.org/data/2.5/onecall?lat=${coords.lat}&lon=${coords.lon}&\r\n    exclude=daily&appid=${apiKey}&units=metric`)\r\n    nextSevenDays = await nextSevenDays.json();\r\n    nextSevenDays = nextSevenDays.daily;\r\n  }\r\n  \r\n\r\n\r\n  const weatherData = new WeatherInformation(weatherByPosition);\r\n  weatherData.setWeatherInformation();\r\n  const chart = new Chart(weatherByHour, axisXposition);\r\n  chart.chart();\r\n  const forecastForWeek = new WeekForecast(nextSevenDays);\r\n  forecastForWeek.addWeatherForecast();\r\n  \r\n}\r\n\r\nconst localization = document.getElementsByClassName('header__geolocalization--buttonJS')[0];\r\nconst searchButton = document.getElementsByClassName('header__search--buttonJS')[0];\r\nconst inputField = document.getElementsByClassName('header__search--inputJS')[0];\r\n\r\n\r\nlocalization.addEventListener('click', async () => {\r\n  const locations = await main_location();\r\n  await getLocation(locations);\r\n  if(!classStatus) {\r\n    replaceClasses();\r\n    classStatus = true\r\n  }\r\n})\r\n\r\nsearchButton.addEventListener('click', async () => {\r\n  if (!inputField.value) {\r\n    alert(\"please type your city name\");\r\n  }\r\n  else if (inputField.value) {\r\n    try {\r\n      await getLocation(inputField.value);\r\n      \r\n      if(!classStatus) {\r\n        replaceClasses();\r\n        classStatus = true;\r\n      }\r\n\r\n    }\r\n    catch(error) {\r\n      alert('Please type corret city name')\r\n    }\r\n  }\r\n})\r\n\r\nfunction replaceClasses() {\r\n  const header = document.getElementsByClassName(\"header--firstLoad\")[0];\r\n  const main = document.getElementsByClassName(\"main__container--firstLoad\")[0];\r\n  const footer = document.getElementsByClassName(\"footer--firstLoad\")[0];\r\n  \r\n  header.classList.replace(\"header--firstLoad\", \"header\");\r\n  main.classList.replace(\"main__container--firstLoad\", \"main__container\");\r\n  footer.classList.replace(\"header--firstLoad\", \"footer\");\r\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvanMvd2VhdGhlckluZm9ybWF0aW9uLmpzPzU2YTkiLCJ3ZWJwYWNrOi8vLy4vc3JjL2pzL2NoYXJ0Q2xhc3MuanM/MjAyZCIsIndlYnBhY2s6Ly8vLi9zcmMvanMvd2Vla0ZvcmVjYXN0Q2xhc3MuanM/MjE1OCIsIndlYnBhY2s6Ly8vLi9zcmMvanMvbWFpbi5qcz85MjkxIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7OztBQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG1DQUFtQyxjQUFjLElBQUksYUFBYTtBQUNsRTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0Msb0JBQW9CLE1BQU0sbUNBQW1DLGNBQWMsRUFBRTtBQUMvRzs7QUFFQTtBQUNBO0FBQ0EsNEJBQTRCLHFCQUFxQjtBQUNqRDs7QUFFQTtBQUNBO0FBQ0EsZ0NBQWdDLGNBQWM7QUFDOUM7O0FBRUE7QUFDQTtBQUNBLGdDQUFnQyxjQUFjO0FBQzlDOztBQUVBO0FBQ0E7QUFDQSxpQ0FBaUMsZUFBZTtBQUNoRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsWUFBWTtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBLEc7O0FDNUZPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsUUFBUTtBQUM3QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLHFCQUFxQixTQUFTO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxxQkFBcUIsaUJBQWlCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVzs7QUFFWCxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0M7O0FBRXBDO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBLHlDQUF5QyxrQkFBa0I7QUFDM0Qsd0NBQXdDLGtCQUFrQjs7QUFFMUQ7QUFDQTtBQUNBLHlDQUF5QyxpQkFBaUI7QUFDMUQsd0NBQXdDLGtCQUFrQjtBQUMxRDtBQUNBO0FBQ0EsNENBQTRDLHlCQUF5QixhQUFhLHlCQUF5QjtBQUMzRyxTO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFM7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxHOztBQ2xPTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxzTEFBc0wsNkJBQTZCLDZEQUE2RCxPQUFPLE1BQU0sUUFBUTtBQUNyUyxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQzs7QUNsR2E7QUFDOEM7QUFDckI7QUFDYTtBQUNuRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixxREFBcUQ7QUFDdEU7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7OztBQUlEO0FBQ0EsU0FBUyxTQUFTO0FBQ2xCOztBQUVBO0FBQ0Esd0JBQXdCLFNBQVMsS0FBSyxZQUFZO0FBQ2xEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLFNBQVMsYUFBUTtBQUNqQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXLHNCQUFzQjs7QUFFakM7QUFDQSw2REFBNkQsU0FBUyxPQUFPLFVBQVUsU0FBUyxPQUFPO0FBQ3ZHO0FBQ0E7O0FBRUEsdUZBQXVGLFNBQVMsT0FBTyxVQUFVO0FBQ2pILDJCQUEyQixPQUFPO0FBQ2xDO0FBQ0E7O0FBRUEsdUZBQXVGLFNBQVMsT0FBTyxVQUFVO0FBQ2pILDBCQUEwQixPQUFPO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUZBQXlGLFNBQVMsU0FBUyxPQUFPO0FBQ2xIOztBQUVBO0FBQ0E7QUFDQSx1RkFBdUYsV0FBVyxPQUFPLFdBQVc7QUFDcEgsMkJBQTJCLE9BQU87QUFDbEM7O0FBRUE7O0FBRUEsdUZBQXVGLFdBQVcsT0FBTyxXQUFXO0FBQ3BILDBCQUEwQixPQUFPO0FBQ2pDO0FBQ0E7QUFDQTs7OztBQUlBLDBCQUEwQixrQkFBa0I7QUFDNUM7QUFDQSxvQkFBb0IsS0FBSztBQUN6QjtBQUNBLDhCQUE4QixZQUFZO0FBQzFDOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQSwwQkFBMEIsYUFBUTtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiIwLmpzIiwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGNsYXNzIFdlYXRoZXJJbmZvcm1hdGlvbiB7XHJcbiAgICBjb25zdHJ1Y3Rvcih3ZWF0aGVySW5mbykge1xyXG4gICAgICB0aGlzLmxvY2F0aW9uID0gd2VhdGhlckluZm8ubmFtZSxcclxuICAgICAgdGhpcy5jb3VudHJ5ID0gd2VhdGhlckluZm8uc3lzLmNvdW50cnlcclxuICAgICAgdGhpcy5kYXRlID0gbmV3IERhdGUoKSxcclxuICAgICAgdGhpcy50ZW1wID0gd2VhdGhlckluZm8ubWFpbi50ZW1wLFxyXG4gICAgICB0aGlzLmljb25OYW1lID0gd2VhdGhlckluZm8ud2VhdGhlclswXS5tYWluLFxyXG4gICAgICB0aGlzLnByZXNzdXJlID0gd2VhdGhlckluZm8ubWFpbi5wcmVzc3VyZSxcclxuICAgICAgdGhpcy5odW1pZGl0eSA9IHdlYXRoZXJJbmZvLm1haW4uaHVtaWRpdHksXHJcbiAgICAgIHRoaXMud2luZFNwcGVkID0gd2VhdGhlckluZm8ud2luZC5zcGVlZFxyXG4gICAgfVxyXG4gIFxyXG4gICAgc2V0TG9jYXRpb24oKSB7XHJcbiAgICAgIGNvbnN0IGxvY2F0aW9uSUQgPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKFwiaGVhZFRleHRfX2xvY2F0aW9uLS1qc1wiKVswXTtcclxuICAgICAgbG9jYXRpb25JRC5pbm5lckhUTUwgPSBgaW4gJHt0aGlzLmxvY2F0aW9ufSwgJHt0aGlzLmNvdW50cnl9YDtcclxuICAgIH1cclxuICAgIHNldERhdGUoKSB7XHJcbiAgICAgIGNvbnN0IGRhdGVJRCA9IGRvY3VtZW50LmdldEVsZW1lbnRzQnlDbGFzc05hbWUoXCJoZWFkVGV4dF9fZGF0ZS0tanNcIilbMF07XHJcbiAgICAgIGRhdGVJRC5pbm5lckhUTUwgPSBgVG9kYXkgJHt0aGlzLmRhdGUuZ2V0RGF0ZSgpfXRoLCAke3RoaXMuZGF0ZS50b0xvY2FsZVN0cmluZygnZW4tRU4nLCB7bW9udGg6ICdsb25nJ30pfWBcclxuICAgIH1cclxuICAgIFxyXG4gICAgc2V0VGVtcCgpIHtcclxuICAgICAgY29uc3QgdGVtcElEID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZShcImhlYWRUZXh0LS1kZWdyZWVzLWpzXCIpWzBdO1xyXG4gICAgICB0ZW1wSUQuaW5uZXJIVE1MID0gYCR7dGhpcy50ZW1wLnRvRml4ZWQoMSl9IMKwQ2A7XHJcbiAgICB9XHJcbiAgXHJcbiAgICBzZXRQcmVzc3VyZSgpIHtcclxuICAgICAgY29uc3QgcHJlc3N1cmVJRCA9IGRvY3VtZW50LmdldEVsZW1lbnRzQnlDbGFzc05hbWUoXCJ3ZWF0aGVyVG9kYXlfX3ByZXNzdXJlLS1qc1wiKVswXTtcclxuICAgICAgcHJlc3N1cmVJRC5pbm5lckhUTUwgPSBgJHt0aGlzLnByZXNzdXJlfSBoUGFgO1xyXG4gICAgfVxyXG4gIFxyXG4gICAgc2V0SHVtaWRpdHkoKSB7XHJcbiAgICAgIGNvbnN0IGh1bWlkaXR5SUQgPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKFwid2VhdGhlclRvZGF5X19odW1pZGl0eS0tanNcIilbMF07XHJcbiAgICAgIGh1bWlkaXR5SUQuaW5uZXJIVE1MID0gYCR7dGhpcy5odW1pZGl0eX0gJWA7XHJcbiAgICB9XHJcbiAgXHJcbiAgICBzZXRXaW5kU3BlZWQoKSB7XHJcbiAgICAgIGNvbnN0IHdpbmRTcGVlZElEID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZShcIndlYXRoZXJUb2RheV9fd2luZFNwZWVkLS1qc1wiKVswXTtcclxuICAgICAgd2luZFNwZWVkSUQuaW5uZXJIVE1MID0gYCR7dGhpcy53aW5kU3BwZWR9IG0vc2A7XHJcbiAgICB9XHJcbiAgXHJcbiAgICBzZXRXZWF0aGVySW5mb3JtYXRpb24oKSB7XHJcbiAgICAgIHRoaXMuc2V0TG9jYXRpb24oKTtcclxuICAgICAgdGhpcy5zZXREYXRlKCk7XHJcbiAgICAgIHRoaXMuc2V0VGVtcCgpO1xyXG4gICAgICB0aGlzLnNldFByZXNzdXJlKCk7XHJcbiAgICAgIHRoaXMuc2V0SHVtaWRpdHkoKTtcclxuICAgICAgdGhpcy5zZXRXaW5kU3BlZWQoKTtcclxuICAgIH1cclxuICBcclxuICAgIHdlYXRoZXJJY29uKHdlYXRoZXIpIHtcclxuICAgICAgbGV0IGN1cnJlbnREYXRlID0gbmV3IERhdGUoKTtcclxuICAgICAgY3VycmVudERhdGUgPSBjdXJyZW50RGF0ZS5nZXRIb3VycygpO1xyXG4gICAgICBzd2l0Y2god2VhdGhlcikge1xyXG4gICAgICAgIGNhc2UgJ3RodW5kZXJzdG9ybSc6XHJcbiAgICAgICAgICByZXR1cm4gJ3N0b3JtLnN2Zyc7XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICBjYXNlICdEcml6emxlJzpcclxuICAgICAgICAgIHJldHVybiAnRHJpenpsZS5zdmcnO1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSAnUmFpbic6XHJcbiAgICAgICAgICByZXR1cm4gJ1JhaW4uc3ZnJztcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgJ1Nub3cnOlxyXG4gICAgICAgICAgcmV0dXJuICdTbm93Zmxha2Uuc3ZnJztcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgJ0F0bW9zcGhlcmUnOlxyXG4gICAgICAgICAgcmV0dXJuICdmb2cuc3ZnJztcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgJ0NsZWFyJzpcclxuICAgICAgICAgIGlmKGN1cnJlbnREYXRlIDw9IDIwKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAnc3VuLnN2Zyc7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiAnbW9vbi5zdmcnO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgIH1cclxuICAgICAgICBjYXNlICdDbG91ZHMnOlxyXG4gICAgICAgICAgcmV0dXJuICdDbG91ZHMuc3ZnJ1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICBcclxuICAgIHNldEltYWdlKCkge1xyXG4gICAgICBjb25zdCBpbWFnZUlEID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZShcIndlYXRoZXJJbWFnZS0tanNcIilbMF07XHJcbiAgICAgIGNvbnN0IHdlYXRoZXJOYW1lID0gdGhpcy53ZWF0aGVySWNvbih0aGlzLmljb25OYW1lKTtcclxuICAgICAgaW1hZ2VJRC5zcmMgPSBgYXNzZXRzL2ltZy8ke3dlYXRoZXJOYW1lfWA7XHJcbiAgICB9XHJcbiAgICByb3VuZFRlbXAodGVtcCkge1xyXG4gICAgICByZXR1cm4gTWF0aC5yb3VuZCgodGVtcCAqIDEwMCkvMTAwKTtcclxuICAgIH1cclxuICB9IiwiZXhwb3J0IGNsYXNzIENoYXJ0IHtcclxuICAgIGNvbnN0cnVjdG9yKHdlYXRoZXJEYXRhLCBheGlzWHBvc2l0aW9uKSB7XHJcbiAgICAgIHRoaXMuYXhpc1hwb3NpdGlvbiA9IGF4aXNYcG9zaXRpb247XHJcbiAgICAgIHRoaXMud2VhdGhlckJ5SG91ciA9IHdlYXRoZXJEYXRhO1xyXG4gICAgICB0aGlzLmNvbmRpdGlvbiA9IGZhbHNlO1xyXG4gICAgICB0aGlzLnN0YXRlID0ge307XHJcbiAgICAgIHRoaXMudG9vbHRpcCA9IGRvY3VtZW50LmdldEVsZW1lbnRzQnlDbGFzc05hbWUoXCJjaGFydFRlbXBfX3Rvb2x0aXBcIilbMF07XHJcbiAgICAgIHRoaXMuY2FudmFzID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJjaGFydFRlbXBfX2NhbnZhc1wiKTtcclxuICAgICAgdGhpcy5jdHggPSB0aGlzLmNhbnZhcy5nZXRDb250ZXh0KFwiMmRcIik7XHJcbiAgICB9XHJcbiAgXHJcbiAgICBjYW52YXNEaW1lbnNpb25zKCkge1xyXG4gICAgICB0aGlzLmNhbnZhcy53aWR0aCA9IDY2MDtcclxuICAgICAgdGhpcy5jYW52YXMuaGVpZ2h0ID0gMzA5O1xyXG4gICAgfVxyXG4gIFxyXG4gICAgYmxvY2tzKGNvdW50KSB7XHJcbiAgICAgIHJldHVybiBjb3VudCAqIDQwO1xyXG4gICAgfVxyXG4gIFxyXG4gICAgZHJhd0dyaWQoKSB7XHJcbiAgICAgIGxldCBncmlkWCA9IDQwO1xyXG4gICAgICBsZXQgZ3JpZFkgPSA0MDtcclxuICAgICAgY29uc3QgY2VsbFNpemUgPSA0MDtcclxuICAgICAgdGhpcy5jdHguYmVnaW5QYXRoKCk7XHJcbiAgICAgIHRoaXMuY3R4LnN0cm9rZVN0eWxlID0gXCJsaWdodGdyZXlcIjtcclxuICAgIFxyXG4gICAgICB3aGlsZSAoZ3JpZFggPD0gdGhpcy5jYW52YXMud2lkdGggLSAyMCkge1xyXG4gICAgICAgIHRoaXMuY3R4Lm1vdmVUbyhncmlkWCwgMjApO1xyXG4gICAgICAgIHRoaXMuY3R4LmxpbmVUbyhncmlkWCwgdGhpcy5jYW52YXMuaGVpZ2h0IC0gMjApO1xyXG4gICAgICAgIGdyaWRYICs9IGNlbGxTaXplO1xyXG4gICAgICB9XHJcbiAgICAgIHdoaWxlIChncmlkWSA8PSB0aGlzLmNhbnZhcy5oZWlnaHQgLSAyMCkge1xyXG4gICAgICAgIHRoaXMuY3R4Lm1vdmVUbygyMCwgZ3JpZFkpO1xyXG4gICAgICAgIHRoaXMuY3R4LmxpbmVUbyh0aGlzLmNhbnZhcy53aWR0aCAtIDEwLCBncmlkWSk7XHJcbiAgICAgICAgZ3JpZFkgKz0gY2VsbFNpemU7XHJcbiAgICAgIH1cclxuICAgICAgdGhpcy5jdHguc3Ryb2tlKCk7XHJcbiAgICB9XHJcbiAgXHJcbiAgICBhc3luYyBkcmF3QXhpcyhob3Vycykge1xyXG4gICAgICB0aGlzLmN0eC5iZWdpblBhdGgoKTtcclxuICAgICAgdGhpcy5jdHguc3Ryb2tlU3R5bGUgPSBcImJsYWNrXCI7XHJcbiAgICAgIHRoaXMuY3R4Lm1vdmVUbyh0aGlzLmJsb2NrcygxKSwgdGhpcy5ibG9ja3MoMSAvIDIpKTtcclxuICAgICAgdGhpcy5jdHgubGluZVRvKHRoaXMuYmxvY2tzKDEpLCB0aGlzLmJsb2Nrcyg3KSk7XHJcbiAgICAgIHRoaXMuY3R4LmxpbmVUbyh0aGlzLmJsb2NrcygxNiksIHRoaXMuYmxvY2tzKDcpKTtcclxuICAgIFxyXG4gICAgICB0aGlzLmN0eC5tb3ZlVG8odGhpcy5ibG9ja3MoMSksIHRoaXMuYmxvY2tzKDcpKTtcclxuICAgICAgbGV0IHRleHQgPSAwO1xyXG4gICAgICBsZXQgdGV4dFkgPSB0aGlzLmJsb2Nrcyg3KTtcclxuICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPD0gNzsgaSsrKSB7XHJcbiAgICAgICAgdGhpcy5jdHguc3Ryb2tlVGV4dCh0ZXh0LCB0aGlzLmJsb2NrcygxIC8gMiksIHRleHRZKTtcclxuICAgICAgICB0ZXh0WSAtPSA0MDtcclxuICAgICAgICB0ZXh0ICs9IDU7XHJcbiAgICAgIH1cclxuICAgIFxyXG4gICAgICB0aGlzLmN0eC5tb3ZlVG8odGhpcy5ibG9ja3MoMiksIHRoaXMuYmxvY2tzKDcpKTtcclxuICAgICAgbGV0IHRleHRYID0gdGhpcy5ibG9ja3MoMS45KTtcclxuICAgIFxyXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8PSAxNTsgaSsrKSB7XHJcbiAgICAgICAgdGhpcy5jdHguc3Ryb2tlVGV4dChob3Vyc1tpXSwgdGV4dFgsIHRoaXMuYmxvY2tzKDcuNSkpO1xyXG4gICAgICAgIHRleHRYICs9IDQwO1xyXG4gICAgICB9XHJcbiAgICAgIHRoaXMuY3R4LnN0cm9rZSgpO1xyXG4gICAgfVxyXG4gICAgdGltZXN0YW1wVG9UaW1lKHN0YW1wKSB7XHJcbiAgICAgIGxldCBkYXRlID0gbmV3IERhdGUoc3RhbXAgKiAxMDAwKTtcclxuICAgICAgcmV0dXJuIGRhdGUuZ2V0SG91cnMoKTtcclxuICAgIH1cclxuICAgIFxyXG4gICAgbWFwQW5kRmlsdGVyKHRlbXBBcnJheSkge1xyXG4gICAgICB0ZW1wQXJyYXkgPSB0ZW1wQXJyYXkubWFwKChlbCkgPT4gdGhpcy50aW1lc3RhbXBUb1RpbWUoZWwpKTtcclxuICAgICAgdGVtcEFycmF5ID0gdGVtcEFycmF5LmZpbHRlcigoZWwpID0+IGVsICUgMiA9PSAwKTtcclxuICAgICAgcmV0dXJuIHRlbXBBcnJheTtcclxuICAgIH1cclxuICAgIFxyXG4gICAgdGVtcGVyYXR1cmVUb0NoYXJ0Q29vcmRzKHRlbXApe1xyXG4gICAgICBsZXQgdGVtcGVyYXR1cmUgPSB0ZW1wLm1hcCgoZWwpID0+IGVsIC8gNSk7XHJcbiAgICAgIHRlbXBlcmF0dXJlID0gdGVtcGVyYXR1cmUuc2xpY2UoMCwxNSk7XHJcbiAgICAgIHJldHVybiB0ZW1wZXJhdHVyZTtcclxuICAgIH1cclxuICAgIFxyXG4gICAgZ2V0SG91cnNDb29yZHMoKSB7XHJcbiAgICAgIGxldCBob3VyT2ZUZW1wID0gWy4uLkFycmF5KDE3KS5rZXlzKCldXHJcbiAgICAgIGhvdXJPZlRlbXAgPSBob3VyT2ZUZW1wLnNsaWNlKDIsIDE3KTtcclxuICAgIFxyXG4gICAgICByZXR1cm4gaG91ck9mVGVtcDtcclxuICAgIH1cclxuICAgIFxyXG4gICAgZHJhd0NoYXJ0KHRlbXBlcmF0dXJlKSB7XHJcbiAgICAgIGNvbnN0IHRlbXBIb3VycyA9IHRoaXMuZ2V0SG91cnNDb29yZHMoKTtcclxuICAgICAgbGV0IGkgPSAxO1xyXG4gICAgICBjb25zdCBjb250ZXh0ID0gdGhpcy5jdHhcclxuICAgICAgY29uc3QgYmxvY2sgPSB0aGlzLmJsb2Nrcy5iaW5kKHRoaXMpO1xyXG4gICAgICBjb25zdCBheGlzWHBvc2l0aW9uID0gdGhpcy5heGlzWHBvc2l0aW9uO1xyXG4gICAgICBmdW5jdGlvbiBhbmltYXRpb24oKSB7XHJcbiAgICAgICAgaWYgKGkgPD0gdGVtcGVyYXR1cmUubGVuZ3RoKSB7XHJcbiAgICAgICAgICB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKGFuaW1hdGlvbik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnRleHQuc3Ryb2tlU3R5bGUgPSBcIiNGRkU3NEFcIjtcclxuICAgICAgICBjb250ZXh0LmxpbmVXaWR0aCA9IDM7XHJcbiAgICAgICAgY29udGV4dC5iZWdpblBhdGgoKTtcclxuICAgICAgICBjb250ZXh0Lm1vdmVUbyhibG9jayh0ZW1wSG91cnNbaS0xXSksIGF4aXNYcG9zaXRpb24gLSBibG9jayh0ZW1wZXJhdHVyZVtpLTFdKSk7XHJcbiAgICAgICAgY29udGV4dC5hcmMoYmxvY2sodGVtcEhvdXJzW2ktMV0pLCBheGlzWHBvc2l0aW9uIC0gYmxvY2sodGVtcGVyYXR1cmVbaS0xXSksIDMsIDAsIE1hdGguUEkgKiAyLCB0cnVlKTtcclxuICAgICAgICBjb250ZXh0LmxpbmVUbyhibG9jayh0ZW1wSG91cnNbaV0pLCBheGlzWHBvc2l0aW9uIC0gYmxvY2sodGVtcGVyYXR1cmVbaV0pKTtcclxuICAgICAgICBjb250ZXh0LnN0cm9rZSgpO1xyXG4gICAgICAgIGkrKztcclxuICAgICAgfVxyXG4gICAgICBhbmltYXRpb24oKTtcclxuICAgIH1cclxuICAgIFxyXG4gICAgYXN5bmMgd2FpdEZvckdyaWQobXMpIHtcclxuICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKHIgPT4gc2V0VGltZW91dChyLCBtcykpO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICBnZXRNb3VzZVBvc2l0aW9uKGV2dCkge1xyXG4gICAgICBsZXQgcmVjdCA9IHRoaXMuY2FudmFzLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xyXG4gICAgICByZXR1cm4ge1xyXG4gICAgICAgIHg6IGV2dC5jbGllbnRYIC0gcmVjdC5sZWZ0LFxyXG4gICAgICAgIHk6IGV2dC5jbGllbnRZIC0gcmVjdC50b3BcclxuICAgICAgfTtcclxuICAgIH1cclxuICAgIFxyXG4gICAgZmlsdGVyVGVtcGVyYXR1cmUodGVtcGVyYXR1cmUpIHtcclxuICAgICAgY29uc3QgdGVtcCA9IHRlbXBlcmF0dXJlXHJcbiAgICAgICAgLm1hcCgob2JqKSA9PiBvYmoudGVtcClcclxuICAgICAgICAuZmlsdGVyKChlbCwgaW5kZXgpID0+IGluZGV4ICUgMiA9PSAwKTtcclxuICAgIFxyXG4gICAgICByZXR1cm4gdGVtcDtcclxuICAgIH1cclxuICAgIFxyXG4gICAgdGVtcGVyYXR1cmVUb1BpeGVsKHRlbXApe1xyXG4gICAgICB0ZW1wID0gdGVtcC5tYXAoZWwgPT4gdGhpcy5heGlzWHBvc2l0aW9uIC0gdGhpcy5ibG9ja3MoZWwpKTtcclxuICAgICAgcmV0dXJuIHRlbXA7XHJcbiAgICB9XHJcbiAgICBcclxuICAgIGhvdXJzVG9QaXhlbChob3Vycykge1xyXG4gICAgICBjb25zdCBob3VycnMgPSBob3Vycy5tYXAoZWwgPT4gdGhpcy5ibG9ja3MoZWwpKTtcclxuICAgICAgcmV0dXJuIGhvdXJycztcclxuICAgIH1cclxuICAgIFxyXG4gICAgY3JlYXRlVGVtcE9iaihob3VyLCB0ZW1wLCBob3VyT2ZUZW1wLCB0ZW1wSW5Ib3VyKXtcclxuICAgICAgY29uc3QgdGVtcFBvaW50Q29vcmRzID0gW107XHJcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGVtcC5sZW5ndGg7IGkrKyl7XHJcbiAgICAgICAgdGVtcFBvaW50Q29vcmRzLnB1c2goe1xyXG4gICAgICAgICAgeDogaG91cltpXSxcclxuICAgICAgICAgIHk6IHRlbXBbaV0sXHJcbiAgICAgICAgICB4bWluOiBob3VyW2ldIC0gMyxcclxuICAgICAgICAgIHhtYXg6IGhvdXJbaV0gKyAzLFxyXG4gICAgICAgICAgeW1pbjogdGVtcFtpXSAtIDMsXHJcbiAgICAgICAgICB5bWF4OiB0ZW1wW2ldICsgMyxcclxuICAgICAgICAgIGhvdXJUZW1wOiB7XHJcbiAgICAgICAgICAgIGhvdXI6IGhvdXJPZlRlbXBbaV0sXHJcbiAgICAgICAgICAgIHRlbXA6IHRlbXBJbkhvdXJbaV1cclxuICAgICAgICAgIH0sXHJcbiAgICBcclxuICAgICAgICB9KVxyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiB0ZW1wUG9pbnRDb29yZHM7XHJcbiAgICB9XHJcbiAgICBcclxuICAgIGRyYXdQb2ludChjb29yZHMgPSB7fSwgcmFkaXVzLCBjb2xvciA9ICd3aGl0ZScpIHtcclxuICAgICAgY29uc3QgbW91c2VDb29yZGluYXRlID0gY29vcmRzO1xyXG4gICAgICB0aGlzLmN0eC5zdHJva2VTdHlsZSA9IGNvbG9yO1xyXG4gICAgICB0aGlzLmN0eC5iZWdpblBhdGgoKTtcclxuICAgICAgdGhpcy5jdHgubW92ZVRvKG1vdXNlQ29vcmRpbmF0ZS54LCBtb3VzZUNvb3JkaW5hdGUueSk7XHJcbiAgICAgIHRoaXMuY3R4LmFyYyhtb3VzZUNvb3JkaW5hdGUueCwgbW91c2VDb29yZGluYXRlLnksIHJhZGl1cywgMCwgTWF0aC5QSSAqIDIsIHRydWUpO1xyXG4gICAgICB0aGlzLmN0eC5maWxsU3R5bGUgPSBjb2xvcjtcclxuICAgICAgdGhpcy5jdHguZmlsbCgpO1xyXG4gICAgICB0aGlzLmN0eC5zdHJva2UoKTtcclxuICAgIH1cclxuICAgIFxyXG4gIFxyXG4gICAgYWRkUG9wVXAodGVtcFBvaW50KSB7XHJcbiAgICAgIHRoaXMuY2FudmFzLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIChlKSA9PiB7XHJcbiAgICAgICAgY29uc3QgbW91c2VDb29yZHMgPSB0aGlzLmdldE1vdXNlUG9zaXRpb24oZSk7XHJcbiAgICAgICAgbGV0IGJvb29scyA9IHRlbXBQb2ludC5maWx0ZXIoZWwgPT4ge1xyXG4gICAgICAgICAgY29uc3QgYSA9IGVsLnhtaW4gPD0gbW91c2VDb29yZHMueDtcclxuICAgICAgICAgIGNvbnN0IGIgPSBtb3VzZUNvb3Jkcy54IDw9IGVsLnhtYXg7XHJcbiAgICAgICAgICBjb25zdCBjID0gZWwueW1pbiA8PSBtb3VzZUNvb3Jkcy55O1xyXG4gICAgICAgICAgY29uc3QgZCA9IG1vdXNlQ29vcmRzLnkgPD0gZWwueW1heDtcclxuICAgICAgICAgIHJldHVybiAoYSAmJiBiICYmIGMgJiYgZCl9KVxyXG4gICAgICAgIFxyXG4gICAgICAgIGlmKGJvb29scy5sZW5ndGgpIHtcclxuICAgICAgICAgIHRoaXMuZHJhd1BvaW50KGJvb29sc1swXSwgMSk7XHJcbiAgICAgICAgICB0aGlzLnN0YXRlID0gey4uLmJvb29sc1swXX07XHJcbiAgICAgICAgICB0aGlzLmNvbmRpdGlvbiA9IHRydWU7XHJcbiAgICAgICAgICBpZiAodGhpcy5jYW52YXMud2lkdGggLSAodGhpcy5zdGF0ZS54ICsgNSkgPD0gODApe1xyXG4gICAgICAgICAgICB0aGlzLnRvb2x0aXAuc3R5bGUubGVmdCA9IGAke3RoaXMuc3RhdGUueCAtIDg1fXB4YFxyXG4gICAgICAgICAgICB0aGlzLnRvb2x0aXAuc3R5bGUudG9wID0gYCR7dGhpcy5zdGF0ZS55IC0gMzV9cHhgO1xyXG4gICAgICAgICAgICBcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLnRvb2x0aXAuc3R5bGUubGVmdCA9IGAke3RoaXMuc3RhdGUueCArIDV9cHhgO1xyXG4gICAgICAgICAgICB0aGlzLnRvb2x0aXAuc3R5bGUudG9wID0gYCR7dGhpcy5zdGF0ZS55IC0gMzV9cHhgO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgdGhpcy50b29sdGlwLnN0eWxlLmRpc3BsYXkgPSAnZmxleCc7XHJcbiAgICAgICAgICB0aGlzLnRvb2x0aXAuaW5uZXJIVE1MID0gYFRpbWU6ICR7dGhpcy5zdGF0ZS5ob3VyVGVtcC5ob3VyfTowMCwgVGVtcDogJHt0aGlzLnN0YXRlLmhvdXJUZW1wLnRlbXB9wrBDYDtcclxuICAgICAgICB9IFxyXG4gICAgICAgIGVsc2UgaWYoIWJvb29scy5sZW5ndGgpIHtcclxuICAgICAgICAgIHRoaXMuZHJhd1BvaW50KHRoaXMuc3RhdGUsIDMsIFwiI0ZGRTc0QVwiKTtcclxuICAgICAgICAgIHRoaXMuY29uZGl0aW9uID0gZmFsc2U7XHJcbiAgICAgICAgICB0aGlzLnN0YXRlID0ge307XHJcbiAgICAgICAgICB0aGlzLnRvb2x0aXAuc3R5bGUuZGlzcGxheSA9ICdub25lJztcclxuICAgICAgICB9IFxyXG4gICAgICB9KVxyXG4gICAgfVxyXG4gICAgXHJcbiAgICBhc3luYyBjaGFydCgpIHtcclxuICAgICAgY29uc3QgaG91ck9mV2VhdGhlciA9IHRoaXMubWFwQW5kRmlsdGVyKHRoaXMud2VhdGhlckJ5SG91ci5tYXAoKG9iaikgPT4gb2JqLmR0KSk7XHJcbiAgICAgIGxldCB0ZW1wZXJhdHVyZSA9IHRoaXMuZmlsdGVyVGVtcGVyYXR1cmUodGhpcy53ZWF0aGVyQnlIb3VyKTtcclxuICAgICAgY29uc3QgdGVtcGVyYXR1cmVDb29yZHMgPSB0aGlzLnRlbXBlcmF0dXJlVG9DaGFydENvb3Jkcyh0ZW1wZXJhdHVyZSk7XHJcbiAgICAgIFxyXG4gICAgICBjb25zdCB0ZW1wUGl4ZWxzID0gdGhpcy50ZW1wZXJhdHVyZVRvUGl4ZWwodGVtcGVyYXR1cmVDb29yZHMsIHRoaXMuYXhpc1hwb3NpdGlvbik7XHJcbiAgICAgIGNvbnN0IGhvdXJzUGl4ZWxzID0gdGhpcy5ob3Vyc1RvUGl4ZWwodGhpcy5nZXRIb3Vyc0Nvb3JkcygpKTtcclxuICAgICAgXHJcbiAgICAgIGNvbnN0IHRlbXBQb2ludHMgPSB0aGlzLmNyZWF0ZVRlbXBPYmooaG91cnNQaXhlbHMsIHRlbXBQaXhlbHMsIGhvdXJPZldlYXRoZXIsIHRlbXBlcmF0dXJlKTtcclxuICAgIFxyXG4gICAgICB0aGlzLmNhbnZhc0RpbWVuc2lvbnMoKTtcclxuICAgICAgdGhpcy5kcmF3R3JpZCgpO1xyXG4gICAgICB0aGlzLmRyYXdBeGlzKGhvdXJPZldlYXRoZXIpO1xyXG4gICAgICBhd2FpdCB0aGlzLndhaXRGb3JHcmlkKDUwMCk7XHJcbiAgICAgIHRoaXMuZHJhd0NoYXJ0KHRlbXBlcmF0dXJlQ29vcmRzKVxyXG4gICAgICB0aGlzLmFkZFBvcFVwKHRlbXBQb2ludHMpO1xyXG4gICAgfVxyXG4gIFxyXG4gIH0iLCJleHBvcnQgY2xhc3MgV2Vla0ZvcmVjYXN0IHtcclxuICBjb25zdHJ1Y3Rvcih3ZWVrRm9yZWNhc3REYXRhKSB7XHJcbiAgICB0aGlzLndlZWtEYXRhID0gd2Vla0ZvcmVjYXN0RGF0YTtcclxuICAgIHRoaXMud2VhdGhlckZvcmVjYXN0Q29udGFpbmVyID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZShcIndlYXRoZXJGb3JlY2FzdC0tanNcIik7XHJcbiAgICB0aGlzLndlYXRoZXJGb3JlY2FzdENvbnRhaW5lciA9IHRoaXMud2VhdGhlckZvcmVjYXN0Q29udGFpbmVyWzBdO1xyXG4gIH1cclxuXHJcbiAgc2xpY2VXZWVrRGF0YUFycmF5KCl7XHJcbiAgICB0aGlzLndlZWtEYXRhID0gdGhpcy53ZWVrRGF0YS5zbGljZSgxLDgpO1xyXG4gICAgY29uc29sZS5sb2codGhpcy53ZWVrRGF0YSlcclxuICB9XHJcbiAgZ2V0VGltZXN0YW1wVG9UaW1lKHRpbWVzdGFtcCkge1xyXG4gICAgY29uc3QgdGltZSA9IG5ldyBEYXRlKHRpbWVzdGFtcCAqIDEwMDApO1xyXG4gICAgcmV0dXJuIHRpbWUuZ2V0RGF5KCk7XHJcbiAgfVxyXG4gIGdldE5hbWVPZldlZWsobnVtYmVyKSB7XHJcbiAgICBzd2l0Y2ggKG51bWJlcikge1xyXG4gICAgICBjYXNlIDA6XHJcbiAgICAgICAgcmV0dXJuIFwiU3VuXCI7XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgIGNhc2UgMTpcclxuICAgICAgICByZXR1cm4gXCJNb25cIjtcclxuICAgICAgICBicmVhaztcclxuICAgICAgY2FzZSAyOlxyXG4gICAgICAgIHJldHVybiBcIlR1ZVwiO1xyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICBjYXNlIDM6XHJcbiAgICAgICAgcmV0dXJuIFwiV2VkXCI7XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgIGNhc2UgNDpcclxuICAgICAgICByZXR1cm4gXCJUaHVyXCI7XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgIGNhc2UgNTogXHJcbiAgICAgICAgcmV0dXJuIFwiRnJpXCI7XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgIGNhc2UgNjpcclxuICAgICAgICByZXR1cm4gXCJTYXRcIjtcclxuICAgICAgICBicmVha1xyXG4gICAgfVxyXG4gIH1cclxuICBnZXRXZWF0aGVyUGFyYW1ldGVycygpe1xyXG4gICAgdGhpcy53ZWVrRGF0YSA9IHRoaXMud2Vla0RhdGEubWFwKGVsID0+IHtcclxuICAgICAgcmV0dXJuIHtcclxuICAgICAgICBkYXk6IHRoaXMuZ2V0TmFtZU9mV2Vlayh0aGlzLmdldFRpbWVzdGFtcFRvVGltZShlbC5kdCkpLCBcclxuICAgICAgICB0ZW1wOiBlbC50ZW1wLmRheSxcclxuICAgICAgICB3ZWF0aGVyOiBlbC53ZWF0aGVyWzBdLm1haW5cclxuICAgICAgfVxyXG4gICAgfSk7XHJcbiAgICBjb25zb2xlLmxvZyh0aGlzLndlZWtEYXRhKVxyXG4gIH1cclxuXHJcbiAgcHV0V2VhdGhlckludG9TZWN0aW9uKCl7XHJcbiAgICB0aGlzLndlYXRoZXJGb3JlY2FzdENvbnRhaW5lci5pbm5lckhUTUwgPSAnJztcclxuICAgIHRoaXMud2Vla0RhdGEuZm9yRWFjaChlbCA9PiB7XHJcbiAgICAgIHRoaXMud2VhdGhlckZvcmVjYXN0Q29udGFpbmVyLmlubmVySFRNTCArPSBgPGRpdiBjbGFzcz1cIndlYXRoZXJGb3JlY2FzdF9fZGF5IHdlYXRoZXJGb3JlY2FzdF9fZGF5LS1qc1wiPjxpbWcgY2xhc3M9XCJ3ZWF0aGVyRm9yZWNhc3RfX2RheUVsZW1lbnRcIiBzcmM9Jy9hc3NldHMvaW1nL3dlYXRoZXJpY29ucy8ke3RoaXMud2VhdGhlckljb24oZWwud2VhdGhlcil9JyBhbHQ9Jyc+PC9pbWc+PGRpdiBjbGFzcz1cIndlYXRoZXJGb3JlY2FzdF9fZGF5RWxlbWVudFwiPjxwPiR7ZWwuZGF5fTxicj4ke2VsLnRlbXB9PC9wPjwvZGl2PjwvZGl2PmBcclxuICAgIH0pXHJcbiAgfVxyXG5cclxuICBhZGRXZWF0aGVyRm9yZWNhc3QoKSB7XHJcbiAgICB0aGlzLnNsaWNlV2Vla0RhdGFBcnJheSgpO1xyXG4gICAgdGhpcy5nZXRXZWF0aGVyUGFyYW1ldGVycygpO1xyXG4gICAgdGhpcy5wdXRXZWF0aGVySW50b1NlY3Rpb24oKTtcclxuICB9XHJcblxyXG4gIHdlYXRoZXJJY29uKHdlYXRoZXIpIHtcclxuICAgIGxldCBjdXJyZW50RGF0ZSA9IG5ldyBEYXRlKCk7XHJcbiAgICBjdXJyZW50RGF0ZSA9IGN1cnJlbnREYXRlLmdldEhvdXJzKCk7XHJcbiAgICBzd2l0Y2god2VhdGhlcikge1xyXG4gICAgICBjYXNlICd0aHVuZGVyc3Rvcm0nOlxyXG4gICAgICAgIHJldHVybiAnc3Rvcm0uc3ZnJztcclxuICAgICAgICBicmVhaztcclxuICAgICAgY2FzZSAnRHJpenpsZSc6XHJcbiAgICAgICAgcmV0dXJuICdEcml6emxlLnN2Zyc7XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgIGNhc2UgJ1JhaW4nOlxyXG4gICAgICAgIHJldHVybiAnUmFpbi5zdmcnO1xyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICBjYXNlICdTbm93JzpcclxuICAgICAgICByZXR1cm4gJ1Nub3dmbGFrZS5zdmcnO1xyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICBjYXNlICdBdG1vc3BoZXJlJzpcclxuICAgICAgICByZXR1cm4gJ2ZvZy5zdmcnO1xyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICBjYXNlICdDbGVhcic6XHJcbiAgICAgICAgaWYoY3VycmVudERhdGUgPD0gMjApIHtcclxuICAgICAgICAgIHJldHVybiAnc3VuLnN2Zyc7XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICByZXR1cm4gJ21vb24uc3ZnJztcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuICAgICAgY2FzZSAnQ2xvdWRzJzpcclxuICAgICAgICByZXR1cm4gJ0Nsb3Vkcy5zdmcnXHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxufSIsIlwidXNlIHN0cmljdFwiO1xyXG5pbXBvcnQge1dlYXRoZXJJbmZvcm1hdGlvbn0gZnJvbSAnLi93ZWF0aGVySW5mb3JtYXRpb24uanMnO1xyXG5pbXBvcnQge0NoYXJ0fSBmcm9tICcuL2NoYXJ0Q2xhc3MuanMnO1xyXG5pbXBvcnQge1dlZWtGb3JlY2FzdH0gZnJvbSAnLi93ZWVrRm9yZWNhc3RDbGFzcy5qcydcclxuLy8gc2VydmljZSB3b3JrZXIgcmVnaXN0cmF0aW9uIC0gcmVtb3ZlIGlmIHlvdSdyZSBub3QgZ29pbmcgdG8gdXNlIGl0XHJcblxyXG5pZiAoXCJzZXJ2aWNlV29ya2VyXCIgaW4gbmF2aWdhdG9yKSB7XHJcbiAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJsb2FkXCIsIGZ1bmN0aW9uICgpIHtcclxuICAgIG5hdmlnYXRvci5zZXJ2aWNlV29ya2VyLnJlZ2lzdGVyKFwic2VydmljZXdvcmtlci5qc1wiKS50aGVuKFxyXG4gICAgICBmdW5jdGlvbiAocmVnaXN0cmF0aW9uKSB7XHJcbiAgICAgICAgLy8gUmVnaXN0cmF0aW9uIHdhcyBzdWNjZXNzZnVsXHJcbiAgICAgICAgY29uc29sZS5sb2coXHJcbiAgICAgICAgICBcIlNlcnZpY2VXb3JrZXIgcmVnaXN0cmF0aW9uIHN1Y2Nlc3NmdWwgd2l0aCBzY29wZTogXCIsXHJcbiAgICAgICAgICByZWdpc3RyYXRpb24uc2NvcGVcclxuICAgICAgICApO1xyXG4gICAgICB9LFxyXG4gICAgICBmdW5jdGlvbiAoZXJyKSB7XHJcbiAgICAgICAgLy8gcmVnaXN0cmF0aW9uIGZhaWxlZCA6KFxyXG4gICAgICAgIGNvbnNvbGUubG9nKFwiU2VydmljZVdvcmtlciByZWdpc3RyYXRpb24gZmFpbGVkOiBcIiwgZXJyKTtcclxuICAgICAgfVxyXG4gICAgKTtcclxuICB9KTtcclxufVxyXG5cclxuLy8gcGxhY2UgeW91ciBjb2RlIGJlbG93XHJcbmNvbnN0IGFwaUtleSA9IFwiNTNjNWU5NzY3NWM4ZDNkOGRhMDdlNTZhZWM1YTNhMjJcIjtcclxuY29uc3QgYXhpc1hwb3NpdGlvbiA9IDI4MDsgLy8gWCBheGlzIGlzIG9uIDI4MHB4IENhbnZhcyBIZWlnaHQ7XHJcbmxldCBjbGFzc1N0YXR1cyA9IGZhbHNlO1xyXG5cclxuKGZ1bmN0aW9uICgpIHtcclxuICB2YXIgbGFzdFRpbWUgPSAwO1xyXG4gIHZhciB2ZW5kb3JzID0gWydtcycsICdtb3onLCAnd2Via2l0JywgJ28nXTtcclxuICBmb3IgKHZhciB4ID0gMDsgeCA8IHZlbmRvcnMubGVuZ3RoICYmICF3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lOyArK3gpIHtcclxuICAgICAgd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSA9IHdpbmRvd1t2ZW5kb3JzW3hdICsgJ1JlcXVlc3RBbmltYXRpb25GcmFtZSddO1xyXG4gICAgICB3aW5kb3cuY2FuY2VsQW5pbWF0aW9uRnJhbWUgPSB3aW5kb3dbdmVuZG9yc1t4XSArICdDYW5jZWxBbmltYXRpb25GcmFtZSddIHx8IHdpbmRvd1t2ZW5kb3JzW3hdICsgJ0NhbmNlbFJlcXVlc3RBbmltYXRpb25GcmFtZSddO1xyXG4gIH1cclxuXHJcbiAgaWYgKCF3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKSB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lID0gZnVuY3Rpb24gKGNhbGxiYWNrLCBlbGVtZW50KSB7XHJcbiAgICAgIHZhciBjdXJyVGltZSA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xyXG4gICAgICB2YXIgdGltZVRvQ2FsbCA9IE1hdGgubWF4KDAsIDE2IC0gKGN1cnJUaW1lIC0gbGFzdFRpbWUpKTtcclxuICAgICAgdmFyIGlkID0gd2luZG93LnNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgY2FsbGJhY2soY3VyclRpbWUgKyB0aW1lVG9DYWxsKTtcclxuICAgICAgfSxcclxuICAgICAgdGltZVRvQ2FsbCk7XHJcbiAgICAgIGxhc3RUaW1lID0gY3VyclRpbWUgKyB0aW1lVG9DYWxsO1xyXG4gICAgICByZXR1cm4gaWQ7XHJcbiAgfTtcclxuXHJcbiAgaWYgKCF3aW5kb3cuY2FuY2VsQW5pbWF0aW9uRnJhbWUpIHdpbmRvdy5jYW5jZWxBbmltYXRpb25GcmFtZSA9IGZ1bmN0aW9uIChpZCkge1xyXG4gICAgICBjbGVhclRpbWVvdXQoaWQpO1xyXG4gIH07XHJcbn0oKSk7XHJcblxyXG5cclxuXHJcbmZ1bmN0aW9uIHN1Y2Nlc3MobG9jKSB7XHJcbiAgY29uc3QgeyBjb29yZHMgfSA9IGxvYztcclxufVxyXG5cclxuZnVuY3Rpb24gZXJyb3IoZXJyKSB7XHJcbiAgY29uc29sZS53YXJuKGBFUlJPUigke2Vyci5jb2RlfSk6ICR7ZXJyLm1lc3NhZ2V9YCk7XHJcbn1cclxuXHJcbmNvbnN0IG9wdGlvbnMgPSB7XHJcbiAgZW5hYmxlSGlnaEFjY3VyYWN5OiB0cnVlLFxyXG4gIHRpbWVvdXQ6IDUwMDAsXHJcbiAgbWF4aW11bUFnZTogMCxcclxufTtcclxuXHJcbmZ1bmN0aW9uIGNvbnNvbFZhbHVlKHZhbCkge1xyXG4gIHJldHVybiB2YWw7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGxvY2F0aW9uKCkge1xyXG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PlxyXG4gICAgbmF2aWdhdG9yLmdlb2xvY2F0aW9uLmdldEN1cnJlbnRQb3NpdGlvbihyZXNvbHZlLCBlcnJvcilcclxuICApO1xyXG59XHJcblxyXG5hc3luYyBmdW5jdGlvbiBnZXRMb2NhdGlvbihsb2NhdGlvbikge1xyXG4gIGxldCBwb3NpdGlvbiA9IGxvY2F0aW9uO1xyXG4gIGxldCB3ZWF0aGVyQnlQb3NpdGlvbjtcclxuICBsZXQgd2VhdGhlckJ5SG91cjtcclxuICBsZXQgbmV4dFNldmVuRGF5cztcclxuICBpZiAodHlwZW9mIHBvc2l0aW9uID09PSAnb2JqZWN0Jykge1xyXG4gICAgXHJcbiAgICBwb3NpdGlvbiA9IGF3YWl0IHBvc2l0aW9uLmNvb3JkcztcclxuICAgIGNvbnN0IHsgbGF0aXR1ZGUsIGxvbmdpdHVkZSB9ID0gcG9zaXRpb247XHJcbiAgXHJcbiAgICB3ZWF0aGVyQnlQb3NpdGlvbiA9IGF3YWl0IGZldGNoKFxyXG4gICAgICBgaHR0cHM6Ly9hcGkub3BlbndlYXRoZXJtYXAub3JnL2RhdGEvMi41L3dlYXRoZXI/bGF0PSR7bGF0aXR1ZGV9Jmxvbj0ke2xvbmdpdHVkZX0mYXBwaWQ9JHthcGlLZXl9JnVuaXRzPW1ldHJpYyZsYW5nPXBsYFxyXG4gICAgKTtcclxuICAgIHdlYXRoZXJCeVBvc2l0aW9uID0gYXdhaXQgd2VhdGhlckJ5UG9zaXRpb24uanNvbigpO1xyXG4gICAgXHJcbiAgICB3ZWF0aGVyQnlIb3VyID0gYXdhaXQgZmV0Y2goYGh0dHBzOi8vYXBpLm9wZW53ZWF0aGVybWFwLm9yZy9kYXRhLzIuNS9vbmVjYWxsP2xhdD0ke2xhdGl0dWRlfSZsb249JHtsb25naXR1ZGV9JlxyXG4gICAgZXhjbHVkZT1ob3VybHkmYXBwaWQ9JHthcGlLZXl9JnVuaXRzPW1ldHJpY2ApO1xyXG4gICAgd2VhdGhlckJ5SG91ciA9IGF3YWl0IHdlYXRoZXJCeUhvdXIuanNvbigpO1xyXG4gICAgd2VhdGhlckJ5SG91ciA9IHdlYXRoZXJCeUhvdXIuaG91cmx5O1xyXG4gICAgXHJcbiAgICBuZXh0U2V2ZW5EYXlzID0gYXdhaXQgZmV0Y2goYGh0dHBzOi8vYXBpLm9wZW53ZWF0aGVybWFwLm9yZy9kYXRhLzIuNS9vbmVjYWxsP2xhdD0ke2xhdGl0dWRlfSZsb249JHtsb25naXR1ZGV9JlxyXG4gICAgZXhjbHVkZT1kYWlseSZhcHBpZD0ke2FwaUtleX0mdW5pdHM9bWV0cmljYClcclxuICAgIG5leHRTZXZlbkRheXMgPSBhd2FpdCBuZXh0U2V2ZW5EYXlzLmpzb24oKTtcclxuICAgIG5leHRTZXZlbkRheXMgPSBuZXh0U2V2ZW5EYXlzLmRhaWx5O1xyXG4gIH1cclxuICBlbHNlIHtcclxuICAgIHdlYXRoZXJCeVBvc2l0aW9uID0gYXdhaXQgZmV0Y2goYGh0dHBzOi8vYXBpLm9wZW53ZWF0aGVybWFwLm9yZy9kYXRhLzIuNS93ZWF0aGVyP3E9JHtwb3NpdGlvbn0mYXBwaWQ9JHthcGlLZXl9JnVuaXRzPW1ldHJpY2ApXHJcbiAgICB3ZWF0aGVyQnlQb3NpdGlvbiA9IGF3YWl0IHdlYXRoZXJCeVBvc2l0aW9uLmpzb24oKTtcclxuICAgIFxyXG4gICAgY29uc3QgY29vcmRzID0gd2VhdGhlckJ5UG9zaXRpb24uY29vcmQ7XHJcbiAgICBjb25zb2xlLmxvZyhjb29yZHMpXHJcbiAgICB3ZWF0aGVyQnlIb3VyID0gYXdhaXQgZmV0Y2goYGh0dHBzOi8vYXBpLm9wZW53ZWF0aGVybWFwLm9yZy9kYXRhLzIuNS9vbmVjYWxsP2xhdD0ke2Nvb3Jkcy5sYXR9Jmxvbj0ke2Nvb3Jkcy5sb259JlxyXG4gICAgZXhjbHVkZT1ob3VybHkmYXBwaWQ9JHthcGlLZXl9JnVuaXRzPW1ldHJpY2ApO1xyXG4gICAgd2VhdGhlckJ5SG91ciA9IGF3YWl0IHdlYXRoZXJCeUhvdXIuanNvbigpO1xyXG4gICAgXHJcbiAgICB3ZWF0aGVyQnlIb3VyID0gd2VhdGhlckJ5SG91ci5ob3VybHk7XHJcblxyXG4gICAgbmV4dFNldmVuRGF5cyA9IGF3YWl0IGZldGNoKGBodHRwczovL2FwaS5vcGVud2VhdGhlcm1hcC5vcmcvZGF0YS8yLjUvb25lY2FsbD9sYXQ9JHtjb29yZHMubGF0fSZsb249JHtjb29yZHMubG9ufSZcclxuICAgIGV4Y2x1ZGU9ZGFpbHkmYXBwaWQ9JHthcGlLZXl9JnVuaXRzPW1ldHJpY2ApXHJcbiAgICBuZXh0U2V2ZW5EYXlzID0gYXdhaXQgbmV4dFNldmVuRGF5cy5qc29uKCk7XHJcbiAgICBuZXh0U2V2ZW5EYXlzID0gbmV4dFNldmVuRGF5cy5kYWlseTtcclxuICB9XHJcbiAgXHJcblxyXG5cclxuICBjb25zdCB3ZWF0aGVyRGF0YSA9IG5ldyBXZWF0aGVySW5mb3JtYXRpb24od2VhdGhlckJ5UG9zaXRpb24pO1xyXG4gIHdlYXRoZXJEYXRhLnNldFdlYXRoZXJJbmZvcm1hdGlvbigpO1xyXG4gIGNvbnN0IGNoYXJ0ID0gbmV3IENoYXJ0KHdlYXRoZXJCeUhvdXIsIGF4aXNYcG9zaXRpb24pO1xyXG4gIGNoYXJ0LmNoYXJ0KCk7XHJcbiAgY29uc3QgZm9yZWNhc3RGb3JXZWVrID0gbmV3IFdlZWtGb3JlY2FzdChuZXh0U2V2ZW5EYXlzKTtcclxuICBmb3JlY2FzdEZvcldlZWsuYWRkV2VhdGhlckZvcmVjYXN0KCk7XHJcbiAgXHJcbn1cclxuXHJcbmNvbnN0IGxvY2FsaXphdGlvbiA9IGRvY3VtZW50LmdldEVsZW1lbnRzQnlDbGFzc05hbWUoJ2hlYWRlcl9fZ2VvbG9jYWxpemF0aW9uLS1idXR0b25KUycpWzBdO1xyXG5jb25zdCBzZWFyY2hCdXR0b24gPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKCdoZWFkZXJfX3NlYXJjaC0tYnV0dG9uSlMnKVswXTtcclxuY29uc3QgaW5wdXRGaWVsZCA9IGRvY3VtZW50LmdldEVsZW1lbnRzQnlDbGFzc05hbWUoJ2hlYWRlcl9fc2VhcmNoLS1pbnB1dEpTJylbMF07XHJcblxyXG5cclxubG9jYWxpemF0aW9uLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgYXN5bmMgKCkgPT4ge1xyXG4gIGNvbnN0IGxvY2F0aW9ucyA9IGF3YWl0IGxvY2F0aW9uKCk7XHJcbiAgYXdhaXQgZ2V0TG9jYXRpb24obG9jYXRpb25zKTtcclxuICBpZighY2xhc3NTdGF0dXMpIHtcclxuICAgIHJlcGxhY2VDbGFzc2VzKCk7XHJcbiAgICBjbGFzc1N0YXR1cyA9IHRydWVcclxuICB9XHJcbn0pXHJcblxyXG5zZWFyY2hCdXR0b24uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBhc3luYyAoKSA9PiB7XHJcbiAgaWYgKCFpbnB1dEZpZWxkLnZhbHVlKSB7XHJcbiAgICBhbGVydChcInBsZWFzZSB0eXBlIHlvdXIgY2l0eSBuYW1lXCIpO1xyXG4gIH1cclxuICBlbHNlIGlmIChpbnB1dEZpZWxkLnZhbHVlKSB7XHJcbiAgICB0cnkge1xyXG4gICAgICBhd2FpdCBnZXRMb2NhdGlvbihpbnB1dEZpZWxkLnZhbHVlKTtcclxuICAgICAgXHJcbiAgICAgIGlmKCFjbGFzc1N0YXR1cykge1xyXG4gICAgICAgIHJlcGxhY2VDbGFzc2VzKCk7XHJcbiAgICAgICAgY2xhc3NTdGF0dXMgPSB0cnVlO1xyXG4gICAgICB9XHJcblxyXG4gICAgfVxyXG4gICAgY2F0Y2goZXJyb3IpIHtcclxuICAgICAgYWxlcnQoJ1BsZWFzZSB0eXBlIGNvcnJldCBjaXR5IG5hbWUnKVxyXG4gICAgfVxyXG4gIH1cclxufSlcclxuXHJcbmZ1bmN0aW9uIHJlcGxhY2VDbGFzc2VzKCkge1xyXG4gIGNvbnN0IGhlYWRlciA9IGRvY3VtZW50LmdldEVsZW1lbnRzQnlDbGFzc05hbWUoXCJoZWFkZXItLWZpcnN0TG9hZFwiKVswXTtcclxuICBjb25zdCBtYWluID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZShcIm1haW5fX2NvbnRhaW5lci0tZmlyc3RMb2FkXCIpWzBdO1xyXG4gIGNvbnN0IGZvb3RlciA9IGRvY3VtZW50LmdldEVsZW1lbnRzQnlDbGFzc05hbWUoXCJmb290ZXItLWZpcnN0TG9hZFwiKVswXTtcclxuICBcclxuICBoZWFkZXIuY2xhc3NMaXN0LnJlcGxhY2UoXCJoZWFkZXItLWZpcnN0TG9hZFwiLCBcImhlYWRlclwiKTtcclxuICBtYWluLmNsYXNzTGlzdC5yZXBsYWNlKFwibWFpbl9fY29udGFpbmVyLS1maXJzdExvYWRcIiwgXCJtYWluX19jb250YWluZXJcIik7XHJcbiAgZm9vdGVyLmNsYXNzTGlzdC5yZXBsYWNlKFwiaGVhZGVyLS1maXJzdExvYWRcIiwgXCJmb290ZXJcIik7XHJcbn0iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///0\n")}]);
!function(t){var c={};function g(n){if(c[n])return c[n].exports;var e=c[n]={i:n,l:!1,exports:{}};return t[n].call(e.exports,e,e.exports,g),e.l=!0,e.exports}g.m=t,g.c=c,g.d=function(t,c,n){g.o(t,c)||Object.defineProperty(t,c,{enumerable:!0,get:n})},g.r=function(t){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(t,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(t,"__esModule",{value:!0})},g.t=function(t,c){if(1&c&&(t=g(t)),8&c)return t;if(4&c&&"object"==typeof t&&t&&t.__esModule)return t;var n=Object.create(null);if(g.r(n),Object.defineProperty(n,"default",{enumerable:!0,value:t}),2&c&&"string"!=typeof t)for(var e in t)g.d(n,e,function(c){return t[c]}.bind(null,e));return n},g.n=function(t){var c=t&&t.__esModule?function(){return t.default}:function(){return t};return g.d(c,"a",c),c},g.o=function(t,c){return Object.prototype.hasOwnProperty.call(t,c)},g.p="",g(g.s=0)}([function(module,__webpack_exports__,__webpack_require__){"use strict";eval("__webpack_require__.r(__webpack_exports__);\n\n// CONCATENATED MODULE: ./src/js/weatherInformationClass.js\nclass WeatherInformation {\r\n    constructor(weatherInfo) {\r\n      this.location = weatherInfo.name,\r\n      this.country = weatherInfo.sys.country\r\n      this.date = new Date(),\r\n      this.temp = weatherInfo.main.temp,\r\n      this.iconName = weatherInfo.weather[0].main,\r\n      this.pressure = weatherInfo.main.pressure,\r\n      this.humidity = weatherInfo.main.humidity,\r\n      this.windSpped = weatherInfo.wind.speed\r\n    }\r\n  \r\n    setLocation() {\r\n      const locationID = document.getElementsByClassName(\"headText__location--js\")[0];\r\n      locationID.innerHTML = `in ${this.location}, ${this.country}`;\r\n    }\r\n    setDate() {\r\n      const dateID = document.getElementsByClassName(\"headText__date--js\")[0];\r\n      dateID.innerHTML = `Today ${this.date.getDate()}th, ${this.date.toLocaleString('en-EN', {month: 'long'})}`\r\n    }\r\n    \r\n    setTemp() {\r\n      const tempID = document.getElementsByClassName(\"headText--degrees-js\")[0];\r\n      tempID.innerHTML = `${this.temp.toFixed(1)} °C`;\r\n    }\r\n  \r\n    setPressure() {\r\n      const pressureID = document.getElementsByClassName(\"weatherToday__pressure--js\")[0];\r\n      pressureID.innerHTML = `${this.pressure} hPa`;\r\n    }\r\n  \r\n    setHumidity() {\r\n      const humidityID = document.getElementsByClassName(\"weatherToday__humidity--js\")[0];\r\n      humidityID.innerHTML = `${this.humidity} %`;\r\n    }\r\n  \r\n    setWindSpeed() {\r\n      const windSpeedID = document.getElementsByClassName(\"weatherToday__windSpeed--js\")[0];\r\n      windSpeedID.innerHTML = `${this.windSpped} m/s`;\r\n    }\r\n  \r\n    setWeatherInformation() {\r\n      this.setLocation();\r\n      this.setDate();\r\n      this.setTemp();\r\n      this.setPressure();\r\n      this.setHumidity();\r\n      this.setWindSpeed();\r\n    }\r\n  \r\n    weatherIcon(weather) {\r\n      let currentDate = new Date();\r\n      currentDate = currentDate.getHours();\r\n      switch(weather) {\r\n        case 'thunderstorm':\r\n          return 'storm.svg';\r\n          break;\r\n        case 'Drizzle':\r\n          return 'Drizzle.svg';\r\n          break;\r\n        case 'Rain':\r\n          return 'Rain.svg';\r\n          break;\r\n        case 'Snow':\r\n          return 'Snowflake.svg';\r\n          break;\r\n        case 'Atmosphere':\r\n          return 'fog.svg';\r\n          break;\r\n        case 'Clear':\r\n          if(currentDate <= 20) {\r\n            return 'sun.svg';\r\n            break;\r\n          }\r\n          else {\r\n            return 'moon.svg';\r\n            break;\r\n          }\r\n        case 'Clouds':\r\n          return 'Clouds.svg'\r\n          break;\r\n      }\r\n    }\r\n  \r\n    setImage() {\r\n      const imageID = document.getElementsByClassName(\"weatherImage--js\")[0];\r\n      const weatherName = this.weatherIcon(this.iconName);\r\n      imageID.src = `assets/img/${weatherName}`;\r\n    }\r\n    roundTemp(temp) {\r\n      return Math.round((temp * 100)/100);\r\n    }\r\n  }\n// CONCATENATED MODULE: ./src/js/chartClass.js\nclass Chart {\r\n    constructor(weatherData, axisXposition) {\r\n      this.axisXposition = axisXposition;\r\n      this.weatherByHour = weatherData;\r\n      this.condition = false;\r\n      this.state = {};\r\n      this.tooltip = document.getElementsByClassName(\"chartTemp__tooltip\")[0];\r\n      this.canvas = document.getElementById(\"chartTemp__canvas\");\r\n      this.ctx = this.canvas.getContext(\"2d\");\r\n    }\r\n  \r\n    canvasDimensions() {\r\n      this.canvas.width = 660;\r\n      this.canvas.height = 309;\r\n    }\r\n  \r\n    blocks(count) {\r\n      return count * 40;\r\n    }\r\n  \r\n    drawGrid() {\r\n      let gridX = 40;\r\n      let gridY = 40;\r\n      const cellSize = 40;\r\n      this.ctx.beginPath();\r\n      this.ctx.strokeStyle = \"lightgrey\";\r\n    \r\n      while (gridX <= this.canvas.width - 20) {\r\n        this.ctx.moveTo(gridX, 20);\r\n        this.ctx.lineTo(gridX, this.canvas.height - 20);\r\n        gridX += cellSize;\r\n      }\r\n      while (gridY <= this.canvas.height - 20) {\r\n        this.ctx.moveTo(20, gridY);\r\n        this.ctx.lineTo(this.canvas.width - 10, gridY);\r\n        gridY += cellSize;\r\n      }\r\n      this.ctx.stroke();\r\n    }\r\n  \r\n    async drawAxis(hours) {\r\n      this.ctx.beginPath();\r\n      this.ctx.strokeStyle = \"black\";\r\n      this.ctx.moveTo(this.blocks(1), this.blocks(1 / 2));\r\n      this.ctx.lineTo(this.blocks(1), this.blocks(7));\r\n      this.ctx.lineTo(this.blocks(16), this.blocks(7));\r\n    \r\n      this.ctx.moveTo(this.blocks(1), this.blocks(7));\r\n      let text = 0;\r\n      let textY = this.blocks(7);\r\n      for (let i = 1; i <= 7; i++) {\r\n        this.ctx.strokeText(text, this.blocks(1 / 2), textY);\r\n        textY -= 40;\r\n        text += 5;\r\n      }\r\n    \r\n      this.ctx.moveTo(this.blocks(2), this.blocks(7));\r\n      let textX = this.blocks(1.9);\r\n    \r\n      for (let i = 0; i <= 15; i++) {\r\n        this.ctx.strokeText(hours[i], textX, this.blocks(7.5));\r\n        textX += 40;\r\n      }\r\n      this.ctx.stroke();\r\n    }\r\n    timestampToTime(stamp) {\r\n      let date = new Date(stamp * 1000);\r\n      return date.getHours();\r\n    }\r\n    \r\n    mapAndFilter(tempArray) {\r\n      tempArray = tempArray.map((el) => this.timestampToTime(el));\r\n      tempArray = tempArray.filter((el) => el % 2 == 0);\r\n      return tempArray;\r\n    }\r\n    \r\n    temperatureToChartCoords(temp){\r\n      let temperature = temp.map((el) => el / 5);\r\n      temperature = temperature.slice(0,15);\r\n      return temperature;\r\n    }\r\n    \r\n    getHoursCoords() {\r\n      let hourOfTemp = [...Array(17).keys()]\r\n      hourOfTemp = hourOfTemp.slice(2, 17);\r\n    \r\n      return hourOfTemp;\r\n    }\r\n    \r\n    drawChart(temperature) {\r\n      const tempHours = this.getHoursCoords();\r\n      let i = 1;\r\n      const context = this.ctx\r\n      const block = this.blocks.bind(this);\r\n      const axisXposition = this.axisXposition;\r\n      function animation() {\r\n        if (i <= temperature.length) {\r\n          window.requestAnimationFrame(animation);\r\n        }\r\n        context.strokeStyle = \"#FFE74A\";\r\n        context.lineWidth = 3;\r\n        context.beginPath();\r\n        context.moveTo(block(tempHours[i-1]), axisXposition - block(temperature[i-1]));\r\n        context.arc(block(tempHours[i-1]), axisXposition - block(temperature[i-1]), 3, 0, Math.PI * 2, true);\r\n        context.lineTo(block(tempHours[i]), axisXposition - block(temperature[i]));\r\n        context.stroke();\r\n        i++;\r\n      }\r\n      animation();\r\n    }\r\n    \r\n    async waitForGrid(ms) {\r\n      return new Promise(r => setTimeout(r, ms));\r\n    }\r\n    \r\n    getMousePosition(evt) {\r\n      let rect = this.canvas.getBoundingClientRect();\r\n      return {\r\n        x: evt.clientX - rect.left,\r\n        y: evt.clientY - rect.top\r\n      };\r\n    }\r\n    \r\n    filterTemperature(temperature) {\r\n      const temp = temperature\r\n        .map((obj) => obj.temp)\r\n        .filter((el, index) => index % 2 == 0);\r\n    \r\n      return temp;\r\n    }\r\n    \r\n    temperatureToPixel(temp){\r\n      temp = temp.map(el => this.axisXposition - this.blocks(el));\r\n      return temp;\r\n    }\r\n    \r\n    hoursToPixel(hours) {\r\n      const hourrs = hours.map(el => this.blocks(el));\r\n      return hourrs;\r\n    }\r\n    \r\n    createTempObj(hour, temp, hourOfTemp, tempInHour){\r\n      const tempPointCoords = [];\r\n      for (let i = 0; i < temp.length; i++){\r\n        tempPointCoords.push({\r\n          x: hour[i],\r\n          y: temp[i],\r\n          xmin: hour[i] - 3,\r\n          xmax: hour[i] + 3,\r\n          ymin: temp[i] - 3,\r\n          ymax: temp[i] + 3,\r\n          hourTemp: {\r\n            hour: hourOfTemp[i],\r\n            temp: tempInHour[i]\r\n          },\r\n    \r\n        })\r\n      }\r\n      return tempPointCoords;\r\n    }\r\n    \r\n    drawPoint(coords = {}, radius, color = 'white') {\r\n      const mouseCoordinate = coords;\r\n      this.ctx.strokeStyle = color;\r\n      this.ctx.beginPath();\r\n      this.ctx.moveTo(mouseCoordinate.x, mouseCoordinate.y);\r\n      this.ctx.arc(mouseCoordinate.x, mouseCoordinate.y, radius, 0, Math.PI * 2, true);\r\n      this.ctx.fillStyle = color;\r\n      this.ctx.fill();\r\n      this.ctx.stroke();\r\n    }\r\n    \r\n  \r\n    addPopUp(tempPoint) {\r\n      this.canvas.addEventListener('mousemove', (e) => {\r\n        const mouseCoords = this.getMousePosition(e);\r\n        let boools = tempPoint.filter(el => {\r\n          const a = el.xmin <= mouseCoords.x;\r\n          const b = mouseCoords.x <= el.xmax;\r\n          const c = el.ymin <= mouseCoords.y;\r\n          const d = mouseCoords.y <= el.ymax;\r\n          return (a && b && c && d)})\r\n        \r\n        if(boools.length) {\r\n          this.drawPoint(boools[0], 1);\r\n          this.state = {...boools[0]};\r\n          this.condition = true;\r\n          if (this.canvas.width - (this.state.x + 5) <= 80){\r\n            this.tooltip.style.left = `${this.state.x - 85}px`\r\n            this.tooltip.style.top = `${this.state.y - 35}px`;\r\n            \r\n          }\r\n          else {\r\n            this.tooltip.style.left = `${this.state.x + 5}px`;\r\n            this.tooltip.style.top = `${this.state.y - 35}px`;\r\n          }\r\n          this.tooltip.style.display = 'flex';\r\n          this.tooltip.innerHTML = `Time: ${this.state.hourTemp.hour}:00, Temp: ${this.state.hourTemp.temp}°C`;\r\n        } \r\n        else if(!boools.length) {\r\n          this.drawPoint(this.state, 3, \"#FFE74A\");\r\n          this.condition = false;\r\n          this.state = {};\r\n          this.tooltip.style.display = 'none';\r\n        } \r\n      })\r\n    }\r\n    \r\n    async chart() {\r\n      const hourOfWeather = this.mapAndFilter(this.weatherByHour.map((obj) => obj.dt));\r\n      let temperature = this.filterTemperature(this.weatherByHour);\r\n      const temperatureCoords = this.temperatureToChartCoords(temperature);\r\n      \r\n      const tempPixels = this.temperatureToPixel(temperatureCoords, this.axisXposition);\r\n      const hoursPixels = this.hoursToPixel(this.getHoursCoords());\r\n      \r\n      const tempPoints = this.createTempObj(hoursPixels, tempPixels, hourOfWeather, temperature);\r\n    \r\n      this.canvasDimensions();\r\n      this.drawGrid();\r\n      this.drawAxis(hourOfWeather);\r\n      await this.waitForGrid(500);\r\n      this.drawChart(temperatureCoords)\r\n      this.addPopUp(tempPoints);\r\n    }\r\n  \r\n  }\n// CONCATENATED MODULE: ./src/js/weekForecastClass.js\nclass WeekForecast {\r\n  constructor(weekForecastData) {\r\n    this.weekData = weekForecastData;\r\n    this.weatherForecastContainer = document.getElementsByClassName(\"weatherForecast--js\");\r\n    this.weatherForecastContainer = this.weatherForecastContainer[0];\r\n  }\r\n\r\n  sliceWeekDataArray(){\r\n    this.weekData = this.weekData.slice(1,8);\r\n    console.log(this.weekData)\r\n  }\r\n  getTimestampToTime(timestamp) {\r\n    const time = new Date(timestamp * 1000);\r\n    return time.getDay();\r\n  }\r\n  getNameOfWeek(number) {\r\n    switch (number) {\r\n      case 0:\r\n        return \"Sun\";\r\n        break;\r\n      case 1:\r\n        return \"Mon\";\r\n        break;\r\n      case 2:\r\n        return \"Tue\";\r\n        break;\r\n      case 3:\r\n        return \"Wed\";\r\n        break;\r\n      case 4:\r\n        return \"Thur\";\r\n        break;\r\n      case 5: \r\n        return \"Fri\";\r\n        break;\r\n      case 6:\r\n        return \"Sat\";\r\n        break\r\n    }\r\n  }\r\n  getWeatherParameters(){\r\n    this.weekData = this.weekData.map(el => {\r\n      return {\r\n        day: this.getNameOfWeek(this.getTimestampToTime(el.dt)), \r\n        temp: el.temp.day,\r\n        weather: el.weather[0].main\r\n      }\r\n    });\r\n    console.log(this.weekData)\r\n  }\r\n\r\n  putWeatherIntoSection(){\r\n    this.weatherForecastContainer.innerHTML = '';\r\n    this.weekData.forEach(el => {\r\n      this.weatherForecastContainer.innerHTML += `<div class=\"weatherForecast__day weatherForecast__day--js\"><img class=\"weatherForecast__dayElement\" src='assets/img/weathericons/${this.weatherIcon(el.weather)}' alt=''></img><div class=\"weatherForecast__dayElement\"><p>${el.day}<br>${el.temp}</p></div></div>`\r\n    })\r\n  }\r\n\r\n  addWeatherForecast() {\r\n    this.sliceWeekDataArray();\r\n    this.getWeatherParameters();\r\n    this.putWeatherIntoSection();\r\n  }\r\n\r\n  weatherIcon(weather) {\r\n    let currentDate = new Date();\r\n    currentDate = currentDate.getHours();\r\n    switch(weather) {\r\n      case 'thunderstorm':\r\n        return 'storm.svg';\r\n        break;\r\n      case 'Drizzle':\r\n        return 'Drizzle.svg';\r\n        break;\r\n      case 'Rain':\r\n        return 'Rain.svg';\r\n        break;\r\n      case 'Snow':\r\n        return 'Snowflake.svg';\r\n        break;\r\n      case 'Atmosphere':\r\n        return 'fog.svg';\r\n        break;\r\n      case 'Clear':\r\n        if(currentDate <= 20) {\r\n          return 'sun.svg';\r\n          break;\r\n        }\r\n        else {\r\n          return 'moon.svg';\r\n          break;\r\n        }\r\n      case 'Clouds':\r\n        return 'Clouds.svg'\r\n        break;\r\n    }\r\n  }\r\n\r\n}\n// CONCATENATED MODULE: ./src/js/main.js\n\r\n\r\n\r\n\r\n// service worker registration - remove if you're not going to use it\r\n\r\nif (\"serviceWorker\" in navigator) {\r\n  window.addEventListener(\"load\", function () {\r\n    navigator.serviceWorker.register(\"serviceworker.js\").then(\r\n      function (registration) {\r\n        // Registration was successful\r\n        console.log(\r\n          \"ServiceWorker registration successful with scope: \",\r\n          registration.scope\r\n        );\r\n      },\r\n      function (err) {\r\n        // registration failed :(\r\n        console.log(\"ServiceWorker registration failed: \", err);\r\n      }\r\n    );\r\n  });\r\n}\r\n\r\n// place your code below\r\nconst apiKey = \"53c5e97675c8d3d8da07e56aec5a3a22\";\r\nconst axisXposition = 280; // X axis is on 280px Canvas Height;\r\nlet classStatus = false;\r\n\r\n(function () {\r\n  let lastTime = 0;\r\n  let vendors = ['ms', 'moz', 'webkit', 'o'];\r\n  for (let x = 0; x < vendors.length && !window.requestAnimationFrame; ++x) {\r\n      window.requestAnimationFrame = window[vendors[x] + 'RequestAnimationFrame'];\r\n      window.cancelAnimationFrame = window[vendors[x] + 'CancelAnimationFrame'] || window[vendors[x] + 'CancelRequestAnimationFrame'];\r\n  }\r\n\r\n  if (!window.requestAnimationFrame) window.requestAnimationFrame = function (callback, element) {\r\n      let currTime = new Date().getTime();\r\n      let timeToCall = Math.max(0, 16 - (currTime - lastTime));\r\n      let id = window.setTimeout(function () {\r\n          callback(currTime + timeToCall);\r\n      },\r\n      timeToCall);\r\n      lastTime = currTime + timeToCall;\r\n      return id;\r\n  };\r\n\r\n  if (!window.cancelAnimationFrame) window.cancelAnimationFrame = function (id) {\r\n      clearTimeout(id);\r\n  };\r\n}());\r\n\r\n\r\n\r\nfunction error(err) {\r\n  console.warn(`ERROR(${err.code}): ${err.message}`);\r\n}\r\n\r\nconst options = {\r\n  enableHighAccuracy: true,\r\n  timeout: 5000,\r\n  maximumAge: 0,\r\n};\r\n\r\n\r\nfunction main_location() {\r\n  return new Promise((resolve, reject) =>\r\n    navigator.geolocation.getCurrentPosition(resolve, error)\r\n  );\r\n}\r\n\r\nasync function getLocation(location) {\r\n  let position = location;\r\n  let weatherByPosition;\r\n  let weatherByHour;\r\n  let nextSevenDays;\r\n  if (typeof position === 'object') {\r\n    \r\n    position = await position.coords;\r\n    const { latitude, longitude } = position;\r\n  \r\n    weatherByPosition = await fetch(\r\n      `https://api.openweathermap.org/data/2.5/weather?lat=${latitude}&lon=${longitude}&appid=${apiKey}&units=metric&lang=pl`\r\n    );\r\n    weatherByPosition = await weatherByPosition.json();\r\n    \r\n    weatherByHour = await fetch(`https://api.openweathermap.org/data/2.5/onecall?lat=${latitude}&lon=${longitude}&\r\n    exclude=hourly&appid=${apiKey}&units=metric`);\r\n    weatherByHour = await weatherByHour.json();\r\n    weatherByHour = weatherByHour.hourly;\r\n    \r\n    nextSevenDays = await fetch(`https://api.openweathermap.org/data/2.5/onecall?lat=${latitude}&lon=${longitude}&\r\n    exclude=daily&appid=${apiKey}&units=metric`)\r\n    nextSevenDays = await nextSevenDays.json();\r\n    nextSevenDays = nextSevenDays.daily;\r\n  }\r\n  else {\r\n    weatherByPosition = await fetch(`https://api.openweathermap.org/data/2.5/weather?q=${position}&appid=${apiKey}&units=metric`)\r\n    weatherByPosition = await weatherByPosition.json();\r\n    \r\n    const coords = weatherByPosition.coord;\r\n    console.log(coords)\r\n    weatherByHour = await fetch(`https://api.openweathermap.org/data/2.5/onecall?lat=${coords.lat}&lon=${coords.lon}&\r\n    exclude=hourly&appid=${apiKey}&units=metric`);\r\n    weatherByHour = await weatherByHour.json();\r\n    \r\n    weatherByHour = weatherByHour.hourly;\r\n\r\n    nextSevenDays = await fetch(`https://api.openweathermap.org/data/2.5/onecall?lat=${coords.lat}&lon=${coords.lon}&\r\n    exclude=daily&appid=${apiKey}&units=metric`)\r\n    nextSevenDays = await nextSevenDays.json();\r\n    nextSevenDays = nextSevenDays.daily;\r\n  }\r\n  \r\n\r\n\r\n  const weatherData = new WeatherInformation(weatherByPosition);\r\n  weatherData.setWeatherInformation();\r\n  const chart = new Chart(weatherByHour, axisXposition);\r\n  chart.chart();\r\n  const forecastForWeek = new WeekForecast(nextSevenDays);\r\n  forecastForWeek.addWeatherForecast();\r\n  \r\n}\r\n\r\nconst localization = document.getElementsByClassName('header__geolocalization--buttonJS')[0];\r\nconst searchButton = document.getElementsByClassName('header__search--buttonJS')[0];\r\nconst inputField = document.getElementsByClassName('header__search--inputJS')[0];\r\n\r\n\r\nlocalization.addEventListener('click', async () => {\r\n  const locations = await main_location();\r\n  await getLocation(locations);\r\n  if(!classStatus) {\r\n    replaceClasses();\r\n    classStatus = true\r\n  }\r\n})\r\n\r\nsearchButton.addEventListener('click', async () => {\r\n  if (!inputField.value) {\r\n    alert(\"please type your city name\");\r\n  }\r\n  else if (inputField.value) {\r\n    try {\r\n      await getLocation(inputField.value);\r\n      \r\n      if(!classStatus) {\r\n        replaceClasses();\r\n        classStatus = true;\r\n      }\r\n\r\n    }\r\n    catch(error) {\r\n      alert('Please type corret city name')\r\n    }\r\n  }\r\n})\r\n\r\nfunction replaceClasses() {\r\n  const header = document.getElementsByClassName(\"header--firstLoad\")[0];\r\n  const main = document.getElementsByClassName(\"main__container--firstLoad\")[0];\r\n  const footer = document.getElementsByClassName(\"footer--firstLoad\")[0];\r\n  \r\n  header.classList.replace(\"header--firstLoad\", \"header\");\r\n  main.classList.replace(\"main__container--firstLoad\", \"main__container\");\r\n  footer.classList.replace(\"footer--firstLoad\", \"footer__image\");\r\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvanMvd2VhdGhlckluZm9ybWF0aW9uQ2xhc3MuanM/M2IxZiIsIndlYnBhY2s6Ly8vLi9zcmMvanMvY2hhcnRDbGFzcy5qcz8yMDJkIiwid2VicGFjazovLy8uL3NyYy9qcy93ZWVrRm9yZWNhc3RDbGFzcy5qcz8yMTU4Iiwid2VicGFjazovLy8uL3NyYy9qcy9tYWluLmpzPzkyOTEiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7O0FBQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsbUNBQW1DLGNBQWMsSUFBSSxhQUFhO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxvQkFBb0IsTUFBTSxtQ0FBbUMsY0FBYyxFQUFFO0FBQy9HOztBQUVBO0FBQ0E7QUFDQSw0QkFBNEIscUJBQXFCO0FBQ2pEOztBQUVBO0FBQ0E7QUFDQSxnQ0FBZ0MsY0FBYztBQUM5Qzs7QUFFQTtBQUNBO0FBQ0EsZ0NBQWdDLGNBQWM7QUFDOUM7O0FBRUE7QUFDQTtBQUNBLGlDQUFpQyxlQUFlO0FBQ2hEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxZQUFZO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRzs7QUM1Rk87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixRQUFRO0FBQzdCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEscUJBQXFCLFNBQVM7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHFCQUFxQixpQkFBaUI7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXOztBQUVYLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUEseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQzs7QUFFcEM7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0EseUNBQXlDLGtCQUFrQjtBQUMzRCx3Q0FBd0Msa0JBQWtCOztBQUUxRDtBQUNBO0FBQ0EseUNBQXlDLGlCQUFpQjtBQUMxRCx3Q0FBd0Msa0JBQWtCO0FBQzFEO0FBQ0E7QUFDQSw0Q0FBNEMseUJBQXlCLGFBQWEseUJBQXlCO0FBQzNHLFM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUztBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEc7O0FDbE9PO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHFMQUFxTCw2QkFBNkIsNkRBQTZELE9BQU8sTUFBTSxRQUFRO0FBQ3BTLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDOztBQ2xHYTtBQUNtRDtBQUMxQjtBQUNhO0FBQ25EOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLHFEQUFxRDtBQUN0RTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOzs7O0FBSUQ7QUFDQSx3QkFBd0IsU0FBUyxLQUFLLFlBQVk7QUFDbEQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0EsU0FBUyxhQUFRO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFdBQVcsc0JBQXNCOztBQUVqQztBQUNBLDZEQUE2RCxTQUFTLE9BQU8sVUFBVSxTQUFTLE9BQU87QUFDdkc7QUFDQTs7QUFFQSx1RkFBdUYsU0FBUyxPQUFPLFVBQVU7QUFDakgsMkJBQTJCLE9BQU87QUFDbEM7QUFDQTs7QUFFQSx1RkFBdUYsU0FBUyxPQUFPLFVBQVU7QUFDakgsMEJBQTBCLE9BQU87QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5RkFBeUYsU0FBUyxTQUFTLE9BQU87QUFDbEg7O0FBRUE7QUFDQTtBQUNBLHVGQUF1RixXQUFXLE9BQU8sV0FBVztBQUNwSCwyQkFBMkIsT0FBTztBQUNsQzs7QUFFQTs7QUFFQSx1RkFBdUYsV0FBVyxPQUFPLFdBQVc7QUFDcEgsMEJBQTBCLE9BQU87QUFDakM7QUFDQTtBQUNBOzs7O0FBSUEsMEJBQTBCLGtCQUFrQjtBQUM1QztBQUNBLG9CQUFvQixLQUFLO0FBQ3pCO0FBQ0EsOEJBQThCLFlBQVk7QUFDMUM7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBLDBCQUEwQixhQUFRO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6IjAuanMiLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgY2xhc3MgV2VhdGhlckluZm9ybWF0aW9uIHtcclxuICAgIGNvbnN0cnVjdG9yKHdlYXRoZXJJbmZvKSB7XHJcbiAgICAgIHRoaXMubG9jYXRpb24gPSB3ZWF0aGVySW5mby5uYW1lLFxyXG4gICAgICB0aGlzLmNvdW50cnkgPSB3ZWF0aGVySW5mby5zeXMuY291bnRyeVxyXG4gICAgICB0aGlzLmRhdGUgPSBuZXcgRGF0ZSgpLFxyXG4gICAgICB0aGlzLnRlbXAgPSB3ZWF0aGVySW5mby5tYWluLnRlbXAsXHJcbiAgICAgIHRoaXMuaWNvbk5hbWUgPSB3ZWF0aGVySW5mby53ZWF0aGVyWzBdLm1haW4sXHJcbiAgICAgIHRoaXMucHJlc3N1cmUgPSB3ZWF0aGVySW5mby5tYWluLnByZXNzdXJlLFxyXG4gICAgICB0aGlzLmh1bWlkaXR5ID0gd2VhdGhlckluZm8ubWFpbi5odW1pZGl0eSxcclxuICAgICAgdGhpcy53aW5kU3BwZWQgPSB3ZWF0aGVySW5mby53aW5kLnNwZWVkXHJcbiAgICB9XHJcbiAgXHJcbiAgICBzZXRMb2NhdGlvbigpIHtcclxuICAgICAgY29uc3QgbG9jYXRpb25JRCA9IGRvY3VtZW50LmdldEVsZW1lbnRzQnlDbGFzc05hbWUoXCJoZWFkVGV4dF9fbG9jYXRpb24tLWpzXCIpWzBdO1xyXG4gICAgICBsb2NhdGlvbklELmlubmVySFRNTCA9IGBpbiAke3RoaXMubG9jYXRpb259LCAke3RoaXMuY291bnRyeX1gO1xyXG4gICAgfVxyXG4gICAgc2V0RGF0ZSgpIHtcclxuICAgICAgY29uc3QgZGF0ZUlEID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZShcImhlYWRUZXh0X19kYXRlLS1qc1wiKVswXTtcclxuICAgICAgZGF0ZUlELmlubmVySFRNTCA9IGBUb2RheSAke3RoaXMuZGF0ZS5nZXREYXRlKCl9dGgsICR7dGhpcy5kYXRlLnRvTG9jYWxlU3RyaW5nKCdlbi1FTicsIHttb250aDogJ2xvbmcnfSl9YFxyXG4gICAgfVxyXG4gICAgXHJcbiAgICBzZXRUZW1wKCkge1xyXG4gICAgICBjb25zdCB0ZW1wSUQgPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKFwiaGVhZFRleHQtLWRlZ3JlZXMtanNcIilbMF07XHJcbiAgICAgIHRlbXBJRC5pbm5lckhUTUwgPSBgJHt0aGlzLnRlbXAudG9GaXhlZCgxKX0gwrBDYDtcclxuICAgIH1cclxuICBcclxuICAgIHNldFByZXNzdXJlKCkge1xyXG4gICAgICBjb25zdCBwcmVzc3VyZUlEID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZShcIndlYXRoZXJUb2RheV9fcHJlc3N1cmUtLWpzXCIpWzBdO1xyXG4gICAgICBwcmVzc3VyZUlELmlubmVySFRNTCA9IGAke3RoaXMucHJlc3N1cmV9IGhQYWA7XHJcbiAgICB9XHJcbiAgXHJcbiAgICBzZXRIdW1pZGl0eSgpIHtcclxuICAgICAgY29uc3QgaHVtaWRpdHlJRCA9IGRvY3VtZW50LmdldEVsZW1lbnRzQnlDbGFzc05hbWUoXCJ3ZWF0aGVyVG9kYXlfX2h1bWlkaXR5LS1qc1wiKVswXTtcclxuICAgICAgaHVtaWRpdHlJRC5pbm5lckhUTUwgPSBgJHt0aGlzLmh1bWlkaXR5fSAlYDtcclxuICAgIH1cclxuICBcclxuICAgIHNldFdpbmRTcGVlZCgpIHtcclxuICAgICAgY29uc3Qgd2luZFNwZWVkSUQgPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKFwid2VhdGhlclRvZGF5X193aW5kU3BlZWQtLWpzXCIpWzBdO1xyXG4gICAgICB3aW5kU3BlZWRJRC5pbm5lckhUTUwgPSBgJHt0aGlzLndpbmRTcHBlZH0gbS9zYDtcclxuICAgIH1cclxuICBcclxuICAgIHNldFdlYXRoZXJJbmZvcm1hdGlvbigpIHtcclxuICAgICAgdGhpcy5zZXRMb2NhdGlvbigpO1xyXG4gICAgICB0aGlzLnNldERhdGUoKTtcclxuICAgICAgdGhpcy5zZXRUZW1wKCk7XHJcbiAgICAgIHRoaXMuc2V0UHJlc3N1cmUoKTtcclxuICAgICAgdGhpcy5zZXRIdW1pZGl0eSgpO1xyXG4gICAgICB0aGlzLnNldFdpbmRTcGVlZCgpO1xyXG4gICAgfVxyXG4gIFxyXG4gICAgd2VhdGhlckljb24od2VhdGhlcikge1xyXG4gICAgICBsZXQgY3VycmVudERhdGUgPSBuZXcgRGF0ZSgpO1xyXG4gICAgICBjdXJyZW50RGF0ZSA9IGN1cnJlbnREYXRlLmdldEhvdXJzKCk7XHJcbiAgICAgIHN3aXRjaCh3ZWF0aGVyKSB7XHJcbiAgICAgICAgY2FzZSAndGh1bmRlcnN0b3JtJzpcclxuICAgICAgICAgIHJldHVybiAnc3Rvcm0uc3ZnJztcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgJ0RyaXp6bGUnOlxyXG4gICAgICAgICAgcmV0dXJuICdEcml6emxlLnN2Zyc7XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICBjYXNlICdSYWluJzpcclxuICAgICAgICAgIHJldHVybiAnUmFpbi5zdmcnO1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSAnU25vdyc6XHJcbiAgICAgICAgICByZXR1cm4gJ1Nub3dmbGFrZS5zdmcnO1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSAnQXRtb3NwaGVyZSc6XHJcbiAgICAgICAgICByZXR1cm4gJ2ZvZy5zdmcnO1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSAnQ2xlYXInOlxyXG4gICAgICAgICAgaWYoY3VycmVudERhdGUgPD0gMjApIHtcclxuICAgICAgICAgICAgcmV0dXJuICdzdW4uc3ZnJztcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuICdtb29uLnN2Zyc7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIGNhc2UgJ0Nsb3Vkcyc6XHJcbiAgICAgICAgICByZXR1cm4gJ0Nsb3Vkcy5zdmcnXHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIFxyXG4gICAgc2V0SW1hZ2UoKSB7XHJcbiAgICAgIGNvbnN0IGltYWdlSUQgPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKFwid2VhdGhlckltYWdlLS1qc1wiKVswXTtcclxuICAgICAgY29uc3Qgd2VhdGhlck5hbWUgPSB0aGlzLndlYXRoZXJJY29uKHRoaXMuaWNvbk5hbWUpO1xyXG4gICAgICBpbWFnZUlELnNyYyA9IGBhc3NldHMvaW1nLyR7d2VhdGhlck5hbWV9YDtcclxuICAgIH1cclxuICAgIHJvdW5kVGVtcCh0ZW1wKSB7XHJcbiAgICAgIHJldHVybiBNYXRoLnJvdW5kKCh0ZW1wICogMTAwKS8xMDApO1xyXG4gICAgfVxyXG4gIH0iLCJleHBvcnQgY2xhc3MgQ2hhcnQge1xyXG4gICAgY29uc3RydWN0b3Iod2VhdGhlckRhdGEsIGF4aXNYcG9zaXRpb24pIHtcclxuICAgICAgdGhpcy5heGlzWHBvc2l0aW9uID0gYXhpc1hwb3NpdGlvbjtcclxuICAgICAgdGhpcy53ZWF0aGVyQnlIb3VyID0gd2VhdGhlckRhdGE7XHJcbiAgICAgIHRoaXMuY29uZGl0aW9uID0gZmFsc2U7XHJcbiAgICAgIHRoaXMuc3RhdGUgPSB7fTtcclxuICAgICAgdGhpcy50b29sdGlwID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZShcImNoYXJ0VGVtcF9fdG9vbHRpcFwiKVswXTtcclxuICAgICAgdGhpcy5jYW52YXMgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcImNoYXJ0VGVtcF9fY2FudmFzXCIpO1xyXG4gICAgICB0aGlzLmN0eCA9IHRoaXMuY2FudmFzLmdldENvbnRleHQoXCIyZFwiKTtcclxuICAgIH1cclxuICBcclxuICAgIGNhbnZhc0RpbWVuc2lvbnMoKSB7XHJcbiAgICAgIHRoaXMuY2FudmFzLndpZHRoID0gNjYwO1xyXG4gICAgICB0aGlzLmNhbnZhcy5oZWlnaHQgPSAzMDk7XHJcbiAgICB9XHJcbiAgXHJcbiAgICBibG9ja3MoY291bnQpIHtcclxuICAgICAgcmV0dXJuIGNvdW50ICogNDA7XHJcbiAgICB9XHJcbiAgXHJcbiAgICBkcmF3R3JpZCgpIHtcclxuICAgICAgbGV0IGdyaWRYID0gNDA7XHJcbiAgICAgIGxldCBncmlkWSA9IDQwO1xyXG4gICAgICBjb25zdCBjZWxsU2l6ZSA9IDQwO1xyXG4gICAgICB0aGlzLmN0eC5iZWdpblBhdGgoKTtcclxuICAgICAgdGhpcy5jdHguc3Ryb2tlU3R5bGUgPSBcImxpZ2h0Z3JleVwiO1xyXG4gICAgXHJcbiAgICAgIHdoaWxlIChncmlkWCA8PSB0aGlzLmNhbnZhcy53aWR0aCAtIDIwKSB7XHJcbiAgICAgICAgdGhpcy5jdHgubW92ZVRvKGdyaWRYLCAyMCk7XHJcbiAgICAgICAgdGhpcy5jdHgubGluZVRvKGdyaWRYLCB0aGlzLmNhbnZhcy5oZWlnaHQgLSAyMCk7XHJcbiAgICAgICAgZ3JpZFggKz0gY2VsbFNpemU7XHJcbiAgICAgIH1cclxuICAgICAgd2hpbGUgKGdyaWRZIDw9IHRoaXMuY2FudmFzLmhlaWdodCAtIDIwKSB7XHJcbiAgICAgICAgdGhpcy5jdHgubW92ZVRvKDIwLCBncmlkWSk7XHJcbiAgICAgICAgdGhpcy5jdHgubGluZVRvKHRoaXMuY2FudmFzLndpZHRoIC0gMTAsIGdyaWRZKTtcclxuICAgICAgICBncmlkWSArPSBjZWxsU2l6ZTtcclxuICAgICAgfVxyXG4gICAgICB0aGlzLmN0eC5zdHJva2UoKTtcclxuICAgIH1cclxuICBcclxuICAgIGFzeW5jIGRyYXdBeGlzKGhvdXJzKSB7XHJcbiAgICAgIHRoaXMuY3R4LmJlZ2luUGF0aCgpO1xyXG4gICAgICB0aGlzLmN0eC5zdHJva2VTdHlsZSA9IFwiYmxhY2tcIjtcclxuICAgICAgdGhpcy5jdHgubW92ZVRvKHRoaXMuYmxvY2tzKDEpLCB0aGlzLmJsb2NrcygxIC8gMikpO1xyXG4gICAgICB0aGlzLmN0eC5saW5lVG8odGhpcy5ibG9ja3MoMSksIHRoaXMuYmxvY2tzKDcpKTtcclxuICAgICAgdGhpcy5jdHgubGluZVRvKHRoaXMuYmxvY2tzKDE2KSwgdGhpcy5ibG9ja3MoNykpO1xyXG4gICAgXHJcbiAgICAgIHRoaXMuY3R4Lm1vdmVUbyh0aGlzLmJsb2NrcygxKSwgdGhpcy5ibG9ja3MoNykpO1xyXG4gICAgICBsZXQgdGV4dCA9IDA7XHJcbiAgICAgIGxldCB0ZXh0WSA9IHRoaXMuYmxvY2tzKDcpO1xyXG4gICAgICBmb3IgKGxldCBpID0gMTsgaSA8PSA3OyBpKyspIHtcclxuICAgICAgICB0aGlzLmN0eC5zdHJva2VUZXh0KHRleHQsIHRoaXMuYmxvY2tzKDEgLyAyKSwgdGV4dFkpO1xyXG4gICAgICAgIHRleHRZIC09IDQwO1xyXG4gICAgICAgIHRleHQgKz0gNTtcclxuICAgICAgfVxyXG4gICAgXHJcbiAgICAgIHRoaXMuY3R4Lm1vdmVUbyh0aGlzLmJsb2NrcygyKSwgdGhpcy5ibG9ja3MoNykpO1xyXG4gICAgICBsZXQgdGV4dFggPSB0aGlzLmJsb2NrcygxLjkpO1xyXG4gICAgXHJcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDw9IDE1OyBpKyspIHtcclxuICAgICAgICB0aGlzLmN0eC5zdHJva2VUZXh0KGhvdXJzW2ldLCB0ZXh0WCwgdGhpcy5ibG9ja3MoNy41KSk7XHJcbiAgICAgICAgdGV4dFggKz0gNDA7XHJcbiAgICAgIH1cclxuICAgICAgdGhpcy5jdHguc3Ryb2tlKCk7XHJcbiAgICB9XHJcbiAgICB0aW1lc3RhbXBUb1RpbWUoc3RhbXApIHtcclxuICAgICAgbGV0IGRhdGUgPSBuZXcgRGF0ZShzdGFtcCAqIDEwMDApO1xyXG4gICAgICByZXR1cm4gZGF0ZS5nZXRIb3VycygpO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICBtYXBBbmRGaWx0ZXIodGVtcEFycmF5KSB7XHJcbiAgICAgIHRlbXBBcnJheSA9IHRlbXBBcnJheS5tYXAoKGVsKSA9PiB0aGlzLnRpbWVzdGFtcFRvVGltZShlbCkpO1xyXG4gICAgICB0ZW1wQXJyYXkgPSB0ZW1wQXJyYXkuZmlsdGVyKChlbCkgPT4gZWwgJSAyID09IDApO1xyXG4gICAgICByZXR1cm4gdGVtcEFycmF5O1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICB0ZW1wZXJhdHVyZVRvQ2hhcnRDb29yZHModGVtcCl7XHJcbiAgICAgIGxldCB0ZW1wZXJhdHVyZSA9IHRlbXAubWFwKChlbCkgPT4gZWwgLyA1KTtcclxuICAgICAgdGVtcGVyYXR1cmUgPSB0ZW1wZXJhdHVyZS5zbGljZSgwLDE1KTtcclxuICAgICAgcmV0dXJuIHRlbXBlcmF0dXJlO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICBnZXRIb3Vyc0Nvb3JkcygpIHtcclxuICAgICAgbGV0IGhvdXJPZlRlbXAgPSBbLi4uQXJyYXkoMTcpLmtleXMoKV1cclxuICAgICAgaG91ck9mVGVtcCA9IGhvdXJPZlRlbXAuc2xpY2UoMiwgMTcpO1xyXG4gICAgXHJcbiAgICAgIHJldHVybiBob3VyT2ZUZW1wO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICBkcmF3Q2hhcnQodGVtcGVyYXR1cmUpIHtcclxuICAgICAgY29uc3QgdGVtcEhvdXJzID0gdGhpcy5nZXRIb3Vyc0Nvb3JkcygpO1xyXG4gICAgICBsZXQgaSA9IDE7XHJcbiAgICAgIGNvbnN0IGNvbnRleHQgPSB0aGlzLmN0eFxyXG4gICAgICBjb25zdCBibG9jayA9IHRoaXMuYmxvY2tzLmJpbmQodGhpcyk7XHJcbiAgICAgIGNvbnN0IGF4aXNYcG9zaXRpb24gPSB0aGlzLmF4aXNYcG9zaXRpb247XHJcbiAgICAgIGZ1bmN0aW9uIGFuaW1hdGlvbigpIHtcclxuICAgICAgICBpZiAoaSA8PSB0ZW1wZXJhdHVyZS5sZW5ndGgpIHtcclxuICAgICAgICAgIHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoYW5pbWF0aW9uKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29udGV4dC5zdHJva2VTdHlsZSA9IFwiI0ZGRTc0QVwiO1xyXG4gICAgICAgIGNvbnRleHQubGluZVdpZHRoID0gMztcclxuICAgICAgICBjb250ZXh0LmJlZ2luUGF0aCgpO1xyXG4gICAgICAgIGNvbnRleHQubW92ZVRvKGJsb2NrKHRlbXBIb3Vyc1tpLTFdKSwgYXhpc1hwb3NpdGlvbiAtIGJsb2NrKHRlbXBlcmF0dXJlW2ktMV0pKTtcclxuICAgICAgICBjb250ZXh0LmFyYyhibG9jayh0ZW1wSG91cnNbaS0xXSksIGF4aXNYcG9zaXRpb24gLSBibG9jayh0ZW1wZXJhdHVyZVtpLTFdKSwgMywgMCwgTWF0aC5QSSAqIDIsIHRydWUpO1xyXG4gICAgICAgIGNvbnRleHQubGluZVRvKGJsb2NrKHRlbXBIb3Vyc1tpXSksIGF4aXNYcG9zaXRpb24gLSBibG9jayh0ZW1wZXJhdHVyZVtpXSkpO1xyXG4gICAgICAgIGNvbnRleHQuc3Ryb2tlKCk7XHJcbiAgICAgICAgaSsrO1xyXG4gICAgICB9XHJcbiAgICAgIGFuaW1hdGlvbigpO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICBhc3luYyB3YWl0Rm9yR3JpZChtcykge1xyXG4gICAgICByZXR1cm4gbmV3IFByb21pc2UociA9PiBzZXRUaW1lb3V0KHIsIG1zKSk7XHJcbiAgICB9XHJcbiAgICBcclxuICAgIGdldE1vdXNlUG9zaXRpb24oZXZ0KSB7XHJcbiAgICAgIGxldCByZWN0ID0gdGhpcy5jYW52YXMuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XHJcbiAgICAgIHJldHVybiB7XHJcbiAgICAgICAgeDogZXZ0LmNsaWVudFggLSByZWN0LmxlZnQsXHJcbiAgICAgICAgeTogZXZ0LmNsaWVudFkgLSByZWN0LnRvcFxyXG4gICAgICB9O1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICBmaWx0ZXJUZW1wZXJhdHVyZSh0ZW1wZXJhdHVyZSkge1xyXG4gICAgICBjb25zdCB0ZW1wID0gdGVtcGVyYXR1cmVcclxuICAgICAgICAubWFwKChvYmopID0+IG9iai50ZW1wKVxyXG4gICAgICAgIC5maWx0ZXIoKGVsLCBpbmRleCkgPT4gaW5kZXggJSAyID09IDApO1xyXG4gICAgXHJcbiAgICAgIHJldHVybiB0ZW1wO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICB0ZW1wZXJhdHVyZVRvUGl4ZWwodGVtcCl7XHJcbiAgICAgIHRlbXAgPSB0ZW1wLm1hcChlbCA9PiB0aGlzLmF4aXNYcG9zaXRpb24gLSB0aGlzLmJsb2NrcyhlbCkpO1xyXG4gICAgICByZXR1cm4gdGVtcDtcclxuICAgIH1cclxuICAgIFxyXG4gICAgaG91cnNUb1BpeGVsKGhvdXJzKSB7XHJcbiAgICAgIGNvbnN0IGhvdXJycyA9IGhvdXJzLm1hcChlbCA9PiB0aGlzLmJsb2NrcyhlbCkpO1xyXG4gICAgICByZXR1cm4gaG91cnJzO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICBjcmVhdGVUZW1wT2JqKGhvdXIsIHRlbXAsIGhvdXJPZlRlbXAsIHRlbXBJbkhvdXIpe1xyXG4gICAgICBjb25zdCB0ZW1wUG9pbnRDb29yZHMgPSBbXTtcclxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0ZW1wLmxlbmd0aDsgaSsrKXtcclxuICAgICAgICB0ZW1wUG9pbnRDb29yZHMucHVzaCh7XHJcbiAgICAgICAgICB4OiBob3VyW2ldLFxyXG4gICAgICAgICAgeTogdGVtcFtpXSxcclxuICAgICAgICAgIHhtaW46IGhvdXJbaV0gLSAzLFxyXG4gICAgICAgICAgeG1heDogaG91cltpXSArIDMsXHJcbiAgICAgICAgICB5bWluOiB0ZW1wW2ldIC0gMyxcclxuICAgICAgICAgIHltYXg6IHRlbXBbaV0gKyAzLFxyXG4gICAgICAgICAgaG91clRlbXA6IHtcclxuICAgICAgICAgICAgaG91cjogaG91ck9mVGVtcFtpXSxcclxuICAgICAgICAgICAgdGVtcDogdGVtcEluSG91cltpXVxyXG4gICAgICAgICAgfSxcclxuICAgIFxyXG4gICAgICAgIH0pXHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIHRlbXBQb2ludENvb3JkcztcclxuICAgIH1cclxuICAgIFxyXG4gICAgZHJhd1BvaW50KGNvb3JkcyA9IHt9LCByYWRpdXMsIGNvbG9yID0gJ3doaXRlJykge1xyXG4gICAgICBjb25zdCBtb3VzZUNvb3JkaW5hdGUgPSBjb29yZHM7XHJcbiAgICAgIHRoaXMuY3R4LnN0cm9rZVN0eWxlID0gY29sb3I7XHJcbiAgICAgIHRoaXMuY3R4LmJlZ2luUGF0aCgpO1xyXG4gICAgICB0aGlzLmN0eC5tb3ZlVG8obW91c2VDb29yZGluYXRlLngsIG1vdXNlQ29vcmRpbmF0ZS55KTtcclxuICAgICAgdGhpcy5jdHguYXJjKG1vdXNlQ29vcmRpbmF0ZS54LCBtb3VzZUNvb3JkaW5hdGUueSwgcmFkaXVzLCAwLCBNYXRoLlBJICogMiwgdHJ1ZSk7XHJcbiAgICAgIHRoaXMuY3R4LmZpbGxTdHlsZSA9IGNvbG9yO1xyXG4gICAgICB0aGlzLmN0eC5maWxsKCk7XHJcbiAgICAgIHRoaXMuY3R4LnN0cm9rZSgpO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgXHJcbiAgICBhZGRQb3BVcCh0ZW1wUG9pbnQpIHtcclxuICAgICAgdGhpcy5jYW52YXMuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgKGUpID0+IHtcclxuICAgICAgICBjb25zdCBtb3VzZUNvb3JkcyA9IHRoaXMuZ2V0TW91c2VQb3NpdGlvbihlKTtcclxuICAgICAgICBsZXQgYm9vb2xzID0gdGVtcFBvaW50LmZpbHRlcihlbCA9PiB7XHJcbiAgICAgICAgICBjb25zdCBhID0gZWwueG1pbiA8PSBtb3VzZUNvb3Jkcy54O1xyXG4gICAgICAgICAgY29uc3QgYiA9IG1vdXNlQ29vcmRzLnggPD0gZWwueG1heDtcclxuICAgICAgICAgIGNvbnN0IGMgPSBlbC55bWluIDw9IG1vdXNlQ29vcmRzLnk7XHJcbiAgICAgICAgICBjb25zdCBkID0gbW91c2VDb29yZHMueSA8PSBlbC55bWF4O1xyXG4gICAgICAgICAgcmV0dXJuIChhICYmIGIgJiYgYyAmJiBkKX0pXHJcbiAgICAgICAgXHJcbiAgICAgICAgaWYoYm9vb2xzLmxlbmd0aCkge1xyXG4gICAgICAgICAgdGhpcy5kcmF3UG9pbnQoYm9vb2xzWzBdLCAxKTtcclxuICAgICAgICAgIHRoaXMuc3RhdGUgPSB7Li4uYm9vb2xzWzBdfTtcclxuICAgICAgICAgIHRoaXMuY29uZGl0aW9uID0gdHJ1ZTtcclxuICAgICAgICAgIGlmICh0aGlzLmNhbnZhcy53aWR0aCAtICh0aGlzLnN0YXRlLnggKyA1KSA8PSA4MCl7XHJcbiAgICAgICAgICAgIHRoaXMudG9vbHRpcC5zdHlsZS5sZWZ0ID0gYCR7dGhpcy5zdGF0ZS54IC0gODV9cHhgXHJcbiAgICAgICAgICAgIHRoaXMudG9vbHRpcC5zdHlsZS50b3AgPSBgJHt0aGlzLnN0YXRlLnkgLSAzNX1weGA7XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMudG9vbHRpcC5zdHlsZS5sZWZ0ID0gYCR7dGhpcy5zdGF0ZS54ICsgNX1weGA7XHJcbiAgICAgICAgICAgIHRoaXMudG9vbHRpcC5zdHlsZS50b3AgPSBgJHt0aGlzLnN0YXRlLnkgLSAzNX1weGA7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICB0aGlzLnRvb2x0aXAuc3R5bGUuZGlzcGxheSA9ICdmbGV4JztcclxuICAgICAgICAgIHRoaXMudG9vbHRpcC5pbm5lckhUTUwgPSBgVGltZTogJHt0aGlzLnN0YXRlLmhvdXJUZW1wLmhvdXJ9OjAwLCBUZW1wOiAke3RoaXMuc3RhdGUuaG91clRlbXAudGVtcH3CsENgO1xyXG4gICAgICAgIH0gXHJcbiAgICAgICAgZWxzZSBpZighYm9vb2xzLmxlbmd0aCkge1xyXG4gICAgICAgICAgdGhpcy5kcmF3UG9pbnQodGhpcy5zdGF0ZSwgMywgXCIjRkZFNzRBXCIpO1xyXG4gICAgICAgICAgdGhpcy5jb25kaXRpb24gPSBmYWxzZTtcclxuICAgICAgICAgIHRoaXMuc3RhdGUgPSB7fTtcclxuICAgICAgICAgIHRoaXMudG9vbHRpcC5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xyXG4gICAgICAgIH0gXHJcbiAgICAgIH0pXHJcbiAgICB9XHJcbiAgICBcclxuICAgIGFzeW5jIGNoYXJ0KCkge1xyXG4gICAgICBjb25zdCBob3VyT2ZXZWF0aGVyID0gdGhpcy5tYXBBbmRGaWx0ZXIodGhpcy53ZWF0aGVyQnlIb3VyLm1hcCgob2JqKSA9PiBvYmouZHQpKTtcclxuICAgICAgbGV0IHRlbXBlcmF0dXJlID0gdGhpcy5maWx0ZXJUZW1wZXJhdHVyZSh0aGlzLndlYXRoZXJCeUhvdXIpO1xyXG4gICAgICBjb25zdCB0ZW1wZXJhdHVyZUNvb3JkcyA9IHRoaXMudGVtcGVyYXR1cmVUb0NoYXJ0Q29vcmRzKHRlbXBlcmF0dXJlKTtcclxuICAgICAgXHJcbiAgICAgIGNvbnN0IHRlbXBQaXhlbHMgPSB0aGlzLnRlbXBlcmF0dXJlVG9QaXhlbCh0ZW1wZXJhdHVyZUNvb3JkcywgdGhpcy5heGlzWHBvc2l0aW9uKTtcclxuICAgICAgY29uc3QgaG91cnNQaXhlbHMgPSB0aGlzLmhvdXJzVG9QaXhlbCh0aGlzLmdldEhvdXJzQ29vcmRzKCkpO1xyXG4gICAgICBcclxuICAgICAgY29uc3QgdGVtcFBvaW50cyA9IHRoaXMuY3JlYXRlVGVtcE9iaihob3Vyc1BpeGVscywgdGVtcFBpeGVscywgaG91ck9mV2VhdGhlciwgdGVtcGVyYXR1cmUpO1xyXG4gICAgXHJcbiAgICAgIHRoaXMuY2FudmFzRGltZW5zaW9ucygpO1xyXG4gICAgICB0aGlzLmRyYXdHcmlkKCk7XHJcbiAgICAgIHRoaXMuZHJhd0F4aXMoaG91ck9mV2VhdGhlcik7XHJcbiAgICAgIGF3YWl0IHRoaXMud2FpdEZvckdyaWQoNTAwKTtcclxuICAgICAgdGhpcy5kcmF3Q2hhcnQodGVtcGVyYXR1cmVDb29yZHMpXHJcbiAgICAgIHRoaXMuYWRkUG9wVXAodGVtcFBvaW50cyk7XHJcbiAgICB9XHJcbiAgXHJcbiAgfSIsImV4cG9ydCBjbGFzcyBXZWVrRm9yZWNhc3Qge1xyXG4gIGNvbnN0cnVjdG9yKHdlZWtGb3JlY2FzdERhdGEpIHtcclxuICAgIHRoaXMud2Vla0RhdGEgPSB3ZWVrRm9yZWNhc3REYXRhO1xyXG4gICAgdGhpcy53ZWF0aGVyRm9yZWNhc3RDb250YWluZXIgPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKFwid2VhdGhlckZvcmVjYXN0LS1qc1wiKTtcclxuICAgIHRoaXMud2VhdGhlckZvcmVjYXN0Q29udGFpbmVyID0gdGhpcy53ZWF0aGVyRm9yZWNhc3RDb250YWluZXJbMF07XHJcbiAgfVxyXG5cclxuICBzbGljZVdlZWtEYXRhQXJyYXkoKXtcclxuICAgIHRoaXMud2Vla0RhdGEgPSB0aGlzLndlZWtEYXRhLnNsaWNlKDEsOCk7XHJcbiAgICBjb25zb2xlLmxvZyh0aGlzLndlZWtEYXRhKVxyXG4gIH1cclxuICBnZXRUaW1lc3RhbXBUb1RpbWUodGltZXN0YW1wKSB7XHJcbiAgICBjb25zdCB0aW1lID0gbmV3IERhdGUodGltZXN0YW1wICogMTAwMCk7XHJcbiAgICByZXR1cm4gdGltZS5nZXREYXkoKTtcclxuICB9XHJcbiAgZ2V0TmFtZU9mV2VlayhudW1iZXIpIHtcclxuICAgIHN3aXRjaCAobnVtYmVyKSB7XHJcbiAgICAgIGNhc2UgMDpcclxuICAgICAgICByZXR1cm4gXCJTdW5cIjtcclxuICAgICAgICBicmVhaztcclxuICAgICAgY2FzZSAxOlxyXG4gICAgICAgIHJldHVybiBcIk1vblwiO1xyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICBjYXNlIDI6XHJcbiAgICAgICAgcmV0dXJuIFwiVHVlXCI7XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgIGNhc2UgMzpcclxuICAgICAgICByZXR1cm4gXCJXZWRcIjtcclxuICAgICAgICBicmVhaztcclxuICAgICAgY2FzZSA0OlxyXG4gICAgICAgIHJldHVybiBcIlRodXJcIjtcclxuICAgICAgICBicmVhaztcclxuICAgICAgY2FzZSA1OiBcclxuICAgICAgICByZXR1cm4gXCJGcmlcIjtcclxuICAgICAgICBicmVhaztcclxuICAgICAgY2FzZSA2OlxyXG4gICAgICAgIHJldHVybiBcIlNhdFwiO1xyXG4gICAgICAgIGJyZWFrXHJcbiAgICB9XHJcbiAgfVxyXG4gIGdldFdlYXRoZXJQYXJhbWV0ZXJzKCl7XHJcbiAgICB0aGlzLndlZWtEYXRhID0gdGhpcy53ZWVrRGF0YS5tYXAoZWwgPT4ge1xyXG4gICAgICByZXR1cm4ge1xyXG4gICAgICAgIGRheTogdGhpcy5nZXROYW1lT2ZXZWVrKHRoaXMuZ2V0VGltZXN0YW1wVG9UaW1lKGVsLmR0KSksIFxyXG4gICAgICAgIHRlbXA6IGVsLnRlbXAuZGF5LFxyXG4gICAgICAgIHdlYXRoZXI6IGVsLndlYXRoZXJbMF0ubWFpblxyXG4gICAgICB9XHJcbiAgICB9KTtcclxuICAgIGNvbnNvbGUubG9nKHRoaXMud2Vla0RhdGEpXHJcbiAgfVxyXG5cclxuICBwdXRXZWF0aGVySW50b1NlY3Rpb24oKXtcclxuICAgIHRoaXMud2VhdGhlckZvcmVjYXN0Q29udGFpbmVyLmlubmVySFRNTCA9ICcnO1xyXG4gICAgdGhpcy53ZWVrRGF0YS5mb3JFYWNoKGVsID0+IHtcclxuICAgICAgdGhpcy53ZWF0aGVyRm9yZWNhc3RDb250YWluZXIuaW5uZXJIVE1MICs9IGA8ZGl2IGNsYXNzPVwid2VhdGhlckZvcmVjYXN0X19kYXkgd2VhdGhlckZvcmVjYXN0X19kYXktLWpzXCI+PGltZyBjbGFzcz1cIndlYXRoZXJGb3JlY2FzdF9fZGF5RWxlbWVudFwiIHNyYz0nYXNzZXRzL2ltZy93ZWF0aGVyaWNvbnMvJHt0aGlzLndlYXRoZXJJY29uKGVsLndlYXRoZXIpfScgYWx0PScnPjwvaW1nPjxkaXYgY2xhc3M9XCJ3ZWF0aGVyRm9yZWNhc3RfX2RheUVsZW1lbnRcIj48cD4ke2VsLmRheX08YnI+JHtlbC50ZW1wfTwvcD48L2Rpdj48L2Rpdj5gXHJcbiAgICB9KVxyXG4gIH1cclxuXHJcbiAgYWRkV2VhdGhlckZvcmVjYXN0KCkge1xyXG4gICAgdGhpcy5zbGljZVdlZWtEYXRhQXJyYXkoKTtcclxuICAgIHRoaXMuZ2V0V2VhdGhlclBhcmFtZXRlcnMoKTtcclxuICAgIHRoaXMucHV0V2VhdGhlckludG9TZWN0aW9uKCk7XHJcbiAgfVxyXG5cclxuICB3ZWF0aGVySWNvbih3ZWF0aGVyKSB7XHJcbiAgICBsZXQgY3VycmVudERhdGUgPSBuZXcgRGF0ZSgpO1xyXG4gICAgY3VycmVudERhdGUgPSBjdXJyZW50RGF0ZS5nZXRIb3VycygpO1xyXG4gICAgc3dpdGNoKHdlYXRoZXIpIHtcclxuICAgICAgY2FzZSAndGh1bmRlcnN0b3JtJzpcclxuICAgICAgICByZXR1cm4gJ3N0b3JtLnN2Zyc7XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgIGNhc2UgJ0RyaXp6bGUnOlxyXG4gICAgICAgIHJldHVybiAnRHJpenpsZS5zdmcnO1xyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICBjYXNlICdSYWluJzpcclxuICAgICAgICByZXR1cm4gJ1JhaW4uc3ZnJztcclxuICAgICAgICBicmVhaztcclxuICAgICAgY2FzZSAnU25vdyc6XHJcbiAgICAgICAgcmV0dXJuICdTbm93Zmxha2Uuc3ZnJztcclxuICAgICAgICBicmVhaztcclxuICAgICAgY2FzZSAnQXRtb3NwaGVyZSc6XHJcbiAgICAgICAgcmV0dXJuICdmb2cuc3ZnJztcclxuICAgICAgICBicmVhaztcclxuICAgICAgY2FzZSAnQ2xlYXInOlxyXG4gICAgICAgIGlmKGN1cnJlbnREYXRlIDw9IDIwKSB7XHJcbiAgICAgICAgICByZXR1cm4gJ3N1bi5zdmcnO1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgcmV0dXJuICdtb29uLnN2Zyc7XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcbiAgICAgIGNhc2UgJ0Nsb3Vkcyc6XHJcbiAgICAgICAgcmV0dXJuICdDbG91ZHMuc3ZnJ1xyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbn0iLCJcInVzZSBzdHJpY3RcIjtcclxuaW1wb3J0IHtXZWF0aGVySW5mb3JtYXRpb259IGZyb20gJy4vd2VhdGhlckluZm9ybWF0aW9uQ2xhc3MuanMnO1xyXG5pbXBvcnQge0NoYXJ0fSBmcm9tICcuL2NoYXJ0Q2xhc3MuanMnO1xyXG5pbXBvcnQge1dlZWtGb3JlY2FzdH0gZnJvbSAnLi93ZWVrRm9yZWNhc3RDbGFzcy5qcydcclxuLy8gc2VydmljZSB3b3JrZXIgcmVnaXN0cmF0aW9uIC0gcmVtb3ZlIGlmIHlvdSdyZSBub3QgZ29pbmcgdG8gdXNlIGl0XHJcblxyXG5pZiAoXCJzZXJ2aWNlV29ya2VyXCIgaW4gbmF2aWdhdG9yKSB7XHJcbiAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJsb2FkXCIsIGZ1bmN0aW9uICgpIHtcclxuICAgIG5hdmlnYXRvci5zZXJ2aWNlV29ya2VyLnJlZ2lzdGVyKFwic2VydmljZXdvcmtlci5qc1wiKS50aGVuKFxyXG4gICAgICBmdW5jdGlvbiAocmVnaXN0cmF0aW9uKSB7XHJcbiAgICAgICAgLy8gUmVnaXN0cmF0aW9uIHdhcyBzdWNjZXNzZnVsXHJcbiAgICAgICAgY29uc29sZS5sb2coXHJcbiAgICAgICAgICBcIlNlcnZpY2VXb3JrZXIgcmVnaXN0cmF0aW9uIHN1Y2Nlc3NmdWwgd2l0aCBzY29wZTogXCIsXHJcbiAgICAgICAgICByZWdpc3RyYXRpb24uc2NvcGVcclxuICAgICAgICApO1xyXG4gICAgICB9LFxyXG4gICAgICBmdW5jdGlvbiAoZXJyKSB7XHJcbiAgICAgICAgLy8gcmVnaXN0cmF0aW9uIGZhaWxlZCA6KFxyXG4gICAgICAgIGNvbnNvbGUubG9nKFwiU2VydmljZVdvcmtlciByZWdpc3RyYXRpb24gZmFpbGVkOiBcIiwgZXJyKTtcclxuICAgICAgfVxyXG4gICAgKTtcclxuICB9KTtcclxufVxyXG5cclxuLy8gcGxhY2UgeW91ciBjb2RlIGJlbG93XHJcbmNvbnN0IGFwaUtleSA9IFwiNTNjNWU5NzY3NWM4ZDNkOGRhMDdlNTZhZWM1YTNhMjJcIjtcclxuY29uc3QgYXhpc1hwb3NpdGlvbiA9IDI4MDsgLy8gWCBheGlzIGlzIG9uIDI4MHB4IENhbnZhcyBIZWlnaHQ7XHJcbmxldCBjbGFzc1N0YXR1cyA9IGZhbHNlO1xyXG5cclxuKGZ1bmN0aW9uICgpIHtcclxuICBsZXQgbGFzdFRpbWUgPSAwO1xyXG4gIGxldCB2ZW5kb3JzID0gWydtcycsICdtb3onLCAnd2Via2l0JywgJ28nXTtcclxuICBmb3IgKGxldCB4ID0gMDsgeCA8IHZlbmRvcnMubGVuZ3RoICYmICF3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lOyArK3gpIHtcclxuICAgICAgd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSA9IHdpbmRvd1t2ZW5kb3JzW3hdICsgJ1JlcXVlc3RBbmltYXRpb25GcmFtZSddO1xyXG4gICAgICB3aW5kb3cuY2FuY2VsQW5pbWF0aW9uRnJhbWUgPSB3aW5kb3dbdmVuZG9yc1t4XSArICdDYW5jZWxBbmltYXRpb25GcmFtZSddIHx8IHdpbmRvd1t2ZW5kb3JzW3hdICsgJ0NhbmNlbFJlcXVlc3RBbmltYXRpb25GcmFtZSddO1xyXG4gIH1cclxuXHJcbiAgaWYgKCF3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKSB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lID0gZnVuY3Rpb24gKGNhbGxiYWNrLCBlbGVtZW50KSB7XHJcbiAgICAgIGxldCBjdXJyVGltZSA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xyXG4gICAgICBsZXQgdGltZVRvQ2FsbCA9IE1hdGgubWF4KDAsIDE2IC0gKGN1cnJUaW1lIC0gbGFzdFRpbWUpKTtcclxuICAgICAgbGV0IGlkID0gd2luZG93LnNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgY2FsbGJhY2soY3VyclRpbWUgKyB0aW1lVG9DYWxsKTtcclxuICAgICAgfSxcclxuICAgICAgdGltZVRvQ2FsbCk7XHJcbiAgICAgIGxhc3RUaW1lID0gY3VyclRpbWUgKyB0aW1lVG9DYWxsO1xyXG4gICAgICByZXR1cm4gaWQ7XHJcbiAgfTtcclxuXHJcbiAgaWYgKCF3aW5kb3cuY2FuY2VsQW5pbWF0aW9uRnJhbWUpIHdpbmRvdy5jYW5jZWxBbmltYXRpb25GcmFtZSA9IGZ1bmN0aW9uIChpZCkge1xyXG4gICAgICBjbGVhclRpbWVvdXQoaWQpO1xyXG4gIH07XHJcbn0oKSk7XHJcblxyXG5cclxuXHJcbmZ1bmN0aW9uIGVycm9yKGVycikge1xyXG4gIGNvbnNvbGUud2FybihgRVJST1IoJHtlcnIuY29kZX0pOiAke2Vyci5tZXNzYWdlfWApO1xyXG59XHJcblxyXG5jb25zdCBvcHRpb25zID0ge1xyXG4gIGVuYWJsZUhpZ2hBY2N1cmFjeTogdHJ1ZSxcclxuICB0aW1lb3V0OiA1MDAwLFxyXG4gIG1heGltdW1BZ2U6IDAsXHJcbn07XHJcblxyXG5cclxuZnVuY3Rpb24gbG9jYXRpb24oKSB7XHJcbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+XHJcbiAgICBuYXZpZ2F0b3IuZ2VvbG9jYXRpb24uZ2V0Q3VycmVudFBvc2l0aW9uKHJlc29sdmUsIGVycm9yKVxyXG4gICk7XHJcbn1cclxuXHJcbmFzeW5jIGZ1bmN0aW9uIGdldExvY2F0aW9uKGxvY2F0aW9uKSB7XHJcbiAgbGV0IHBvc2l0aW9uID0gbG9jYXRpb247XHJcbiAgbGV0IHdlYXRoZXJCeVBvc2l0aW9uO1xyXG4gIGxldCB3ZWF0aGVyQnlIb3VyO1xyXG4gIGxldCBuZXh0U2V2ZW5EYXlzO1xyXG4gIGlmICh0eXBlb2YgcG9zaXRpb24gPT09ICdvYmplY3QnKSB7XHJcbiAgICBcclxuICAgIHBvc2l0aW9uID0gYXdhaXQgcG9zaXRpb24uY29vcmRzO1xyXG4gICAgY29uc3QgeyBsYXRpdHVkZSwgbG9uZ2l0dWRlIH0gPSBwb3NpdGlvbjtcclxuICBcclxuICAgIHdlYXRoZXJCeVBvc2l0aW9uID0gYXdhaXQgZmV0Y2goXHJcbiAgICAgIGBodHRwczovL2FwaS5vcGVud2VhdGhlcm1hcC5vcmcvZGF0YS8yLjUvd2VhdGhlcj9sYXQ9JHtsYXRpdHVkZX0mbG9uPSR7bG9uZ2l0dWRlfSZhcHBpZD0ke2FwaUtleX0mdW5pdHM9bWV0cmljJmxhbmc9cGxgXHJcbiAgICApO1xyXG4gICAgd2VhdGhlckJ5UG9zaXRpb24gPSBhd2FpdCB3ZWF0aGVyQnlQb3NpdGlvbi5qc29uKCk7XHJcbiAgICBcclxuICAgIHdlYXRoZXJCeUhvdXIgPSBhd2FpdCBmZXRjaChgaHR0cHM6Ly9hcGkub3BlbndlYXRoZXJtYXAub3JnL2RhdGEvMi41L29uZWNhbGw/bGF0PSR7bGF0aXR1ZGV9Jmxvbj0ke2xvbmdpdHVkZX0mXHJcbiAgICBleGNsdWRlPWhvdXJseSZhcHBpZD0ke2FwaUtleX0mdW5pdHM9bWV0cmljYCk7XHJcbiAgICB3ZWF0aGVyQnlIb3VyID0gYXdhaXQgd2VhdGhlckJ5SG91ci5qc29uKCk7XHJcbiAgICB3ZWF0aGVyQnlIb3VyID0gd2VhdGhlckJ5SG91ci5ob3VybHk7XHJcbiAgICBcclxuICAgIG5leHRTZXZlbkRheXMgPSBhd2FpdCBmZXRjaChgaHR0cHM6Ly9hcGkub3BlbndlYXRoZXJtYXAub3JnL2RhdGEvMi41L29uZWNhbGw/bGF0PSR7bGF0aXR1ZGV9Jmxvbj0ke2xvbmdpdHVkZX0mXHJcbiAgICBleGNsdWRlPWRhaWx5JmFwcGlkPSR7YXBpS2V5fSZ1bml0cz1tZXRyaWNgKVxyXG4gICAgbmV4dFNldmVuRGF5cyA9IGF3YWl0IG5leHRTZXZlbkRheXMuanNvbigpO1xyXG4gICAgbmV4dFNldmVuRGF5cyA9IG5leHRTZXZlbkRheXMuZGFpbHk7XHJcbiAgfVxyXG4gIGVsc2Uge1xyXG4gICAgd2VhdGhlckJ5UG9zaXRpb24gPSBhd2FpdCBmZXRjaChgaHR0cHM6Ly9hcGkub3BlbndlYXRoZXJtYXAub3JnL2RhdGEvMi41L3dlYXRoZXI/cT0ke3Bvc2l0aW9ufSZhcHBpZD0ke2FwaUtleX0mdW5pdHM9bWV0cmljYClcclxuICAgIHdlYXRoZXJCeVBvc2l0aW9uID0gYXdhaXQgd2VhdGhlckJ5UG9zaXRpb24uanNvbigpO1xyXG4gICAgXHJcbiAgICBjb25zdCBjb29yZHMgPSB3ZWF0aGVyQnlQb3NpdGlvbi5jb29yZDtcclxuICAgIGNvbnNvbGUubG9nKGNvb3JkcylcclxuICAgIHdlYXRoZXJCeUhvdXIgPSBhd2FpdCBmZXRjaChgaHR0cHM6Ly9hcGkub3BlbndlYXRoZXJtYXAub3JnL2RhdGEvMi41L29uZWNhbGw/bGF0PSR7Y29vcmRzLmxhdH0mbG9uPSR7Y29vcmRzLmxvbn0mXHJcbiAgICBleGNsdWRlPWhvdXJseSZhcHBpZD0ke2FwaUtleX0mdW5pdHM9bWV0cmljYCk7XHJcbiAgICB3ZWF0aGVyQnlIb3VyID0gYXdhaXQgd2VhdGhlckJ5SG91ci5qc29uKCk7XHJcbiAgICBcclxuICAgIHdlYXRoZXJCeUhvdXIgPSB3ZWF0aGVyQnlIb3VyLmhvdXJseTtcclxuXHJcbiAgICBuZXh0U2V2ZW5EYXlzID0gYXdhaXQgZmV0Y2goYGh0dHBzOi8vYXBpLm9wZW53ZWF0aGVybWFwLm9yZy9kYXRhLzIuNS9vbmVjYWxsP2xhdD0ke2Nvb3Jkcy5sYXR9Jmxvbj0ke2Nvb3Jkcy5sb259JlxyXG4gICAgZXhjbHVkZT1kYWlseSZhcHBpZD0ke2FwaUtleX0mdW5pdHM9bWV0cmljYClcclxuICAgIG5leHRTZXZlbkRheXMgPSBhd2FpdCBuZXh0U2V2ZW5EYXlzLmpzb24oKTtcclxuICAgIG5leHRTZXZlbkRheXMgPSBuZXh0U2V2ZW5EYXlzLmRhaWx5O1xyXG4gIH1cclxuICBcclxuXHJcblxyXG4gIGNvbnN0IHdlYXRoZXJEYXRhID0gbmV3IFdlYXRoZXJJbmZvcm1hdGlvbih3ZWF0aGVyQnlQb3NpdGlvbik7XHJcbiAgd2VhdGhlckRhdGEuc2V0V2VhdGhlckluZm9ybWF0aW9uKCk7XHJcbiAgY29uc3QgY2hhcnQgPSBuZXcgQ2hhcnQod2VhdGhlckJ5SG91ciwgYXhpc1hwb3NpdGlvbik7XHJcbiAgY2hhcnQuY2hhcnQoKTtcclxuICBjb25zdCBmb3JlY2FzdEZvcldlZWsgPSBuZXcgV2Vla0ZvcmVjYXN0KG5leHRTZXZlbkRheXMpO1xyXG4gIGZvcmVjYXN0Rm9yV2Vlay5hZGRXZWF0aGVyRm9yZWNhc3QoKTtcclxuICBcclxufVxyXG5cclxuY29uc3QgbG9jYWxpemF0aW9uID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSgnaGVhZGVyX19nZW9sb2NhbGl6YXRpb24tLWJ1dHRvbkpTJylbMF07XHJcbmNvbnN0IHNlYXJjaEJ1dHRvbiA9IGRvY3VtZW50LmdldEVsZW1lbnRzQnlDbGFzc05hbWUoJ2hlYWRlcl9fc2VhcmNoLS1idXR0b25KUycpWzBdO1xyXG5jb25zdCBpbnB1dEZpZWxkID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSgnaGVhZGVyX19zZWFyY2gtLWlucHV0SlMnKVswXTtcclxuXHJcblxyXG5sb2NhbGl6YXRpb24uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBhc3luYyAoKSA9PiB7XHJcbiAgY29uc3QgbG9jYXRpb25zID0gYXdhaXQgbG9jYXRpb24oKTtcclxuICBhd2FpdCBnZXRMb2NhdGlvbihsb2NhdGlvbnMpO1xyXG4gIGlmKCFjbGFzc1N0YXR1cykge1xyXG4gICAgcmVwbGFjZUNsYXNzZXMoKTtcclxuICAgIGNsYXNzU3RhdHVzID0gdHJ1ZVxyXG4gIH1cclxufSlcclxuXHJcbnNlYXJjaEJ1dHRvbi5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGFzeW5jICgpID0+IHtcclxuICBpZiAoIWlucHV0RmllbGQudmFsdWUpIHtcclxuICAgIGFsZXJ0KFwicGxlYXNlIHR5cGUgeW91ciBjaXR5IG5hbWVcIik7XHJcbiAgfVxyXG4gIGVsc2UgaWYgKGlucHV0RmllbGQudmFsdWUpIHtcclxuICAgIHRyeSB7XHJcbiAgICAgIGF3YWl0IGdldExvY2F0aW9uKGlucHV0RmllbGQudmFsdWUpO1xyXG4gICAgICBcclxuICAgICAgaWYoIWNsYXNzU3RhdHVzKSB7XHJcbiAgICAgICAgcmVwbGFjZUNsYXNzZXMoKTtcclxuICAgICAgICBjbGFzc1N0YXR1cyA9IHRydWU7XHJcbiAgICAgIH1cclxuXHJcbiAgICB9XHJcbiAgICBjYXRjaChlcnJvcikge1xyXG4gICAgICBhbGVydCgnUGxlYXNlIHR5cGUgY29ycmV0IGNpdHkgbmFtZScpXHJcbiAgICB9XHJcbiAgfVxyXG59KVxyXG5cclxuZnVuY3Rpb24gcmVwbGFjZUNsYXNzZXMoKSB7XHJcbiAgY29uc3QgaGVhZGVyID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZShcImhlYWRlci0tZmlyc3RMb2FkXCIpWzBdO1xyXG4gIGNvbnN0IG1haW4gPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKFwibWFpbl9fY29udGFpbmVyLS1maXJzdExvYWRcIilbMF07XHJcbiAgY29uc3QgZm9vdGVyID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZShcImZvb3Rlci0tZmlyc3RMb2FkXCIpWzBdO1xyXG4gIFxyXG4gIGhlYWRlci5jbGFzc0xpc3QucmVwbGFjZShcImhlYWRlci0tZmlyc3RMb2FkXCIsIFwiaGVhZGVyXCIpO1xyXG4gIG1haW4uY2xhc3NMaXN0LnJlcGxhY2UoXCJtYWluX19jb250YWluZXItLWZpcnN0TG9hZFwiLCBcIm1haW5fX2NvbnRhaW5lclwiKTtcclxuICBmb290ZXIuY2xhc3NMaXN0LnJlcGxhY2UoXCJmb290ZXItLWZpcnN0TG9hZFwiLCBcImZvb3Rlcl9faW1hZ2VcIik7XHJcbn0iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///0\n")}]);